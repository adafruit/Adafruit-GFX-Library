<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adafruit GFX Library: Adafruit_SPITFT Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adafruit GFX Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_adafruit___s_p_i_t_f_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Adafruit_SPITFT Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> is an intermediary class between <a class="el" href="class_adafruit___g_f_x.html">Adafruit_GFX</a> and various hardware-specific subclasses for different displays. It handles certain operations that are common to a range of displays (address window, area fills, etc.). Originally these were all color TFT displays interfaced via SPI, but it's since expanded to include color OLEDs and parallel-interfaced TFTs. THE NAME HAS BEEN KEPT TO AVOID BREAKING A LOT OF SUBCLASSES AND EXAMPLE CODE. Many of the class member functions similarly live on with names that don't necessarily accurately describe what they're doing, again to avoid breaking a lot of other code. If in doubt, read the comments.  
 <a href="class_adafruit___s_p_i_t_f_t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_adafruit___s_p_i_t_f_t_8h_source.html">Adafruit_SPITFT.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Adafruit_SPITFT:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_adafruit___s_p_i_t_f_t.png" usemap="#Adafruit_5FSPITFT_map" alt=""/>
  <map id="Adafruit_5FSPITFT_map" name="Adafruit_5FSPITFT_map">
<area href="class_adafruit___g_f_x.html" alt="Adafruit_GFX" shape="rect" coords="0,56,105,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae082216e8270f83132827a70cceeaf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#aae082216e8270f83132827a70cceeaf3">Adafruit_SPITFT</a> (uint16_t w, uint16_t h, int8_t cs, int8_t dc, int8_t mosi, int8_t sck, int8_t rst=-1, int8_t miso=-1)</td></tr>
<tr class="memdesc:aae082216e8270f83132827a70cceeaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> constructor for software (bitbang) SPI.  <a href="#aae082216e8270f83132827a70cceeaf3">More...</a><br /></td></tr>
<tr class="separator:aae082216e8270f83132827a70cceeaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3433ca3e3f9c5209765c46751bb674"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a2c3433ca3e3f9c5209765c46751bb674">Adafruit_SPITFT</a> (uint16_t w, uint16_t h, int8_t cs, int8_t dc, int8_t rst=-1)</td></tr>
<tr class="memdesc:a2c3433ca3e3f9c5209765c46751bb674"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> constructor for hardware SPI using the board's default SPI peripheral.  <a href="#a2c3433ca3e3f9c5209765c46751bb674">More...</a><br /></td></tr>
<tr class="separator:a2c3433ca3e3f9c5209765c46751bb674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd847be5c9f71e5741d41805118f05c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#abd847be5c9f71e5741d41805118f05c8">Adafruit_SPITFT</a> (uint16_t w, uint16_t h, SPIClass *spiClass, int8_t cs, int8_t dc, int8_t rst=-1)</td></tr>
<tr class="memdesc:abd847be5c9f71e5741d41805118f05c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> constructor for hardware SPI using a specific SPI peripheral.  <a href="#abd847be5c9f71e5741d41805118f05c8">More...</a><br /></td></tr>
<tr class="separator:abd847be5c9f71e5741d41805118f05c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4a822c07b817cea78dfb35dbaa4525"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a1a4a822c07b817cea78dfb35dbaa4525">Adafruit_SPITFT</a> (uint16_t w, uint16_t h, <a class="el" href="_adafruit___s_p_i_t_f_t_8h.html#a4a7dffd73fe8924b90709aa7e6e366e8">tftBusWidth</a> busWidth, int8_t d0, int8_t wr, int8_t dc, int8_t cs=-1, int8_t rst=-1, int8_t rd=-1)</td></tr>
<tr class="memdesc:a1a4a822c07b817cea78dfb35dbaa4525"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> constructor for parallel display connection.  <a href="#a1a4a822c07b817cea78dfb35dbaa4525">More...</a><br /></td></tr>
<tr class="separator:a1a4a822c07b817cea78dfb35dbaa4525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fb1a7842c52fa1992569880f4ea494"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a81fb1a7842c52fa1992569880f4ea494">begin</a> (uint32_t freq)=0</td></tr>
<tr class="memdesc:a81fb1a7842c52fa1992569880f4ea494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display-specific initialization function.  <a href="#a81fb1a7842c52fa1992569880f4ea494">More...</a><br /></td></tr>
<tr class="separator:a81fb1a7842c52fa1992569880f4ea494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1928d1a2b27cc32422624ed54c0ea932"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a1928d1a2b27cc32422624ed54c0ea932">setAddrWindow</a> (uint16_t x, uint16_t y, uint16_t w, uint16_t h)=0</td></tr>
<tr class="memdesc:a1928d1a2b27cc32422624ed54c0ea932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the specific display hardware's "address window" for subsequent pixel-pushing operations.  <a href="#a1928d1a2b27cc32422624ed54c0ea932">More...</a><br /></td></tr>
<tr class="separator:a1928d1a2b27cc32422624ed54c0ea932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95164c088118b25d8e3efe48f9e86dbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a95164c088118b25d8e3efe48f9e86dbe">initSPI</a> (uint32_t freq=0, uint8_t spiMode=SPI_MODE0)</td></tr>
<tr class="memdesc:a95164c088118b25d8e3efe48f9e86dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure microcontroller pins for TFT interfacing. Typically called by a subclass' <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a81fb1a7842c52fa1992569880f4ea494" title="Display-specific initialization function. ">begin()</a> function.  <a href="#a95164c088118b25d8e3efe48f9e86dbe">More...</a><br /></td></tr>
<tr class="separator:a95164c088118b25d8e3efe48f9e86dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb7f9703e15a7a289e61f5bc450ca4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a4eb7f9703e15a7a289e61f5bc450ca4d">setSPISpeed</a> (uint32_t freq)</td></tr>
<tr class="memdesc:a4eb7f9703e15a7a289e61f5bc450ca4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow changing the SPI clock speed after initialization.  <a href="#a4eb7f9703e15a7a289e61f5bc450ca4d">More...</a><br /></td></tr>
<tr class="separator:a4eb7f9703e15a7a289e61f5bc450ca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15008e1d7d71ccc707f6efab2a86e6b"><td class="memItemLeft" align="right" valign="top"><a id="ad15008e1d7d71ccc707f6efab2a86e6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b">startWrite</a> (void)</td></tr>
<tr class="memdesc:ad15008e1d7d71ccc707f6efab2a86e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an SPI transaction (if using hardware SPI and transactions are supported). Required for all display types; not an SPI-specific function. <br /></td></tr>
<tr class="separator:ad15008e1d7d71ccc707f6efab2a86e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f00bcb36ed34e9f8fb72d45c6d0cad"><td class="memItemLeft" align="right" valign="top"><a id="a65f00bcb36ed34e9f8fb72d45c6d0cad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a65f00bcb36ed34e9f8fb72d45c6d0cad">endWrite</a> (void)</td></tr>
<tr class="memdesc:a65f00bcb36ed34e9f8fb72d45c6d0cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call after issuing command(s) or data to display. Performs chip-deselect (if required) and ends an SPI transaction (if using hardware SPI and transactions are supported). Required for all display types; not an SPI-specific function. <br /></td></tr>
<tr class="separator:a65f00bcb36ed34e9f8fb72d45c6d0cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40496b6d0513cc9a8eef190ced96238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#aa40496b6d0513cc9a8eef190ced96238">sendCommand</a> (uint8_t commandByte, uint8_t *dataBytes=NULL, uint8_t numDataBytes=0)</td></tr>
<tr class="memdesc:aa40496b6d0513cc9a8eef190ced96238"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> Send Command handles complete sending of commands and data.  <a href="#aa40496b6d0513cc9a8eef190ced96238">More...</a><br /></td></tr>
<tr class="separator:aa40496b6d0513cc9a8eef190ced96238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f7cee641ff20ecdb38ca6048e8b68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a25f7cee641ff20ecdb38ca6048e8b68c">sendCommand</a> (uint8_t commandByte, const uint8_t *dataBytes, uint8_t numDataBytes)</td></tr>
<tr class="memdesc:a25f7cee641ff20ecdb38ca6048e8b68c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> Send Command handles complete sending of commands and const data.  <a href="#a25f7cee641ff20ecdb38ca6048e8b68c">More...</a><br /></td></tr>
<tr class="separator:a25f7cee641ff20ecdb38ca6048e8b68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641ccc4f159129259ee08738cb99627b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a641ccc4f159129259ee08738cb99627b">readcommand8</a> (uint8_t commandByte, uint8_t index=0)</td></tr>
<tr class="memdesc:a641ccc4f159129259ee08738cb99627b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 8 bits of data from display configuration memory (not RAM). This is highly undocumented/supported and should be avoided, function is only included because some of the examples use it.  <a href="#a641ccc4f159129259ee08738cb99627b">More...</a><br /></td></tr>
<tr class="separator:a641ccc4f159129259ee08738cb99627b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795dcd9f5f850c057b0a896204fc7d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a795dcd9f5f850c057b0a896204fc7d55">writePixel</a> (int16_t x, int16_t y, uint16_t color)</td></tr>
<tr class="memdesc:a795dcd9f5f850c057b0a896204fc7d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single pixel to the display at requested coordinates. Not self-contained; should follow a <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a> call.  <a href="#a795dcd9f5f850c057b0a896204fc7d55">More...</a><br /></td></tr>
<tr class="separator:a795dcd9f5f850c057b0a896204fc7d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28a0d81eee528cabe3f2fbca6815f05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#af28a0d81eee528cabe3f2fbca6815f05">writePixels</a> (uint16_t *colors, uint32_t len, bool block=true, bool bigEndian=false)</td></tr>
<tr class="memdesc:af28a0d81eee528cabe3f2fbca6815f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue a series of pixels from memory to the display. Not self- contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a> and <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a1928d1a2b27cc32422624ed54c0ea932" title="Set up the specific display hardware&#39;s &quot;address window&quot; for subsequent pixel-pushing operations...">setAddrWindow()</a> calls.  <a href="#af28a0d81eee528cabe3f2fbca6815f05">More...</a><br /></td></tr>
<tr class="separator:af28a0d81eee528cabe3f2fbca6815f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42824e0f1475f2b3df335d31651dc75a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a42824e0f1475f2b3df335d31651dc75a">writeColor</a> (uint16_t color, uint32_t len)</td></tr>
<tr class="memdesc:a42824e0f1475f2b3df335d31651dc75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue a series of pixels, all the same color. Not self- contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a> and <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a1928d1a2b27cc32422624ed54c0ea932" title="Set up the specific display hardware&#39;s &quot;address window&quot; for subsequent pixel-pushing operations...">setAddrWindow()</a> calls.  <a href="#a42824e0f1475f2b3df335d31651dc75a">More...</a><br /></td></tr>
<tr class="separator:a42824e0f1475f2b3df335d31651dc75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df7d60b7c8500b31d0a8f59999c3df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1">writeFillRect</a> (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:a8df7d60b7c8500b31d0a8f59999c3df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a filled rectangle to the display. Not self-contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a>. Typically used by higher-level graphics primitives; user code shouldn't need to call this and is likely to use the self-contained <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a5964fdb249fb43869c649198e13b727b" title="Draw a filled rectangle to the display. Self-contained and provides its own transaction as needed (se...">fillRect()</a> instead. <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1" title="Draw a filled rectangle to the display. Not self-contained; should follow startWrite(). Typically used by higher-level graphics primitives; user code shouldn&#39;t need to call this and is likely to use the self-contained fillRect() instead. writeFillRect() performs its own edge clipping and rejection; see writeFillRectPreclipped() for a more &#39;raw&#39; implementation. ">writeFillRect()</a> performs its own edge clipping and rejection; see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a6ef20b186a133d416f9ba71fb884d275" title="A lower-level version of writeFillRect(). This version requires all inputs are in-bounds, that width and height are positive, and no part extends offscreen. NO EDGE CLIPPING OR REJECTION IS PERFORMED. If higher-level graphics primitives are written to handle their own clipping earlier in the drawing process, this can avoid unnecessary function calls and repeated clipping operations in the lower-level functions. ">writeFillRectPreclipped()</a> for a more 'raw' implementation.  <a href="#a8df7d60b7c8500b31d0a8f59999c3df1">More...</a><br /></td></tr>
<tr class="separator:a8df7d60b7c8500b31d0a8f59999c3df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06312f906256fd7e72efb21df85d2b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a06312f906256fd7e72efb21df85d2b96">writeFastHLine</a> (int16_t x, int16_t y, int16_t w, uint16_t color)</td></tr>
<tr class="memdesc:a06312f906256fd7e72efb21df85d2b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a horizontal line on the display. Performs edge clipping and rejection. Not self-contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a>. Typically used by higher-level graphics primitives; user code shouldn't need to call this and is likely to use the self- contained <a class="el" href="class_adafruit___s_p_i_t_f_t.html#aef1099605952f87fbdf59bc480a7a894" title="Draw a horizontal line on the display. Self-contained and provides its own transaction as needed (see...">drawFastHLine()</a> instead.  <a href="#a06312f906256fd7e72efb21df85d2b96">More...</a><br /></td></tr>
<tr class="separator:a06312f906256fd7e72efb21df85d2b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5f5765414c6b0c94c9a060427803ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a9b5f5765414c6b0c94c9a060427803ec">writeFastVLine</a> (int16_t x, int16_t y, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:a9b5f5765414c6b0c94c9a060427803ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a vertical line on the display. Performs edge clipping and rejection. Not self-contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a>. Typically used by higher-level graphics primitives; user code shouldn't need to call this and is likely to use the self- contained <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ab9bf597887f7098e55e7280d548bc127" title="Draw a vertical line on the display. Self-contained and provides its own transaction as needed (see w...">drawFastVLine()</a> instead.  <a href="#a9b5f5765414c6b0c94c9a060427803ec">More...</a><br /></td></tr>
<tr class="separator:a9b5f5765414c6b0c94c9a060427803ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef20b186a133d416f9ba71fb884d275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a6ef20b186a133d416f9ba71fb884d275">writeFillRectPreclipped</a> (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:a6ef20b186a133d416f9ba71fb884d275"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lower-level version of <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1" title="Draw a filled rectangle to the display. Not self-contained; should follow startWrite(). Typically used by higher-level graphics primitives; user code shouldn&#39;t need to call this and is likely to use the self-contained fillRect() instead. writeFillRect() performs its own edge clipping and rejection; see writeFillRectPreclipped() for a more &#39;raw&#39; implementation. ">writeFillRect()</a>. This version requires all inputs are in-bounds, that width and height are positive, and no part extends offscreen. NO EDGE CLIPPING OR REJECTION IS PERFORMED. If higher-level graphics primitives are written to handle their own clipping earlier in the drawing process, this can avoid unnecessary function calls and repeated clipping operations in the lower-level functions.  <a href="#a6ef20b186a133d416f9ba71fb884d275">More...</a><br /></td></tr>
<tr class="separator:a6ef20b186a133d416f9ba71fb884d275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69f8c2c187cccd5c9df9c25d488f1e5"><td class="memItemLeft" align="right" valign="top"><a id="ae69f8c2c187cccd5c9df9c25d488f1e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ae69f8c2c187cccd5c9df9c25d488f1e5">dmaWait</a> (void)</td></tr>
<tr class="memdesc:ae69f8c2c187cccd5c9df9c25d488f1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the last DMA transfer in a prior non-blocking <a class="el" href="class_adafruit___s_p_i_t_f_t.html#af28a0d81eee528cabe3f2fbca6815f05" title="Issue a series of pixels from memory to the display. Not self- contained; should follow startWrite() ...">writePixels()</a> call to complete. This does nothing if DMA is not enabled, and is not needed if blocking <a class="el" href="class_adafruit___s_p_i_t_f_t.html#af28a0d81eee528cabe3f2fbca6815f05" title="Issue a series of pixels from memory to the display. Not self- contained; should follow startWrite() ...">writePixels()</a> was used (as is the default case). <br /></td></tr>
<tr class="separator:ae69f8c2c187cccd5c9df9c25d488f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e118fc9c0fb141c8ee9f14e49f20704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a5e118fc9c0fb141c8ee9f14e49f20704">drawPixel</a> (int16_t x, int16_t y, uint16_t color)</td></tr>
<tr class="memdesc:a5e118fc9c0fb141c8ee9f14e49f20704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single pixel to the display at requested coordinates. Self-contained and provides its own transaction as needed (see writePixel(x,y,color) for a lower-level variant). Edge clipping is performed here.  <a href="#a5e118fc9c0fb141c8ee9f14e49f20704">More...</a><br /></td></tr>
<tr class="separator:a5e118fc9c0fb141c8ee9f14e49f20704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5964fdb249fb43869c649198e13b727b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a5964fdb249fb43869c649198e13b727b">fillRect</a> (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:a5964fdb249fb43869c649198e13b727b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a filled rectangle to the display. Self-contained and provides its own transaction as needed (see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1" title="Draw a filled rectangle to the display. Not self-contained; should follow startWrite(). Typically used by higher-level graphics primitives; user code shouldn&#39;t need to call this and is likely to use the self-contained fillRect() instead. writeFillRect() performs its own edge clipping and rejection; see writeFillRectPreclipped() for a more &#39;raw&#39; implementation. ">writeFillRect()</a> or <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a6ef20b186a133d416f9ba71fb884d275" title="A lower-level version of writeFillRect(). This version requires all inputs are in-bounds, that width and height are positive, and no part extends offscreen. NO EDGE CLIPPING OR REJECTION IS PERFORMED. If higher-level graphics primitives are written to handle their own clipping earlier in the drawing process, this can avoid unnecessary function calls and repeated clipping operations in the lower-level functions. ">writeFillRectPreclipped()</a> for lower-level variants). Edge clipping and rejection is performed here.  <a href="#a5964fdb249fb43869c649198e13b727b">More...</a><br /></td></tr>
<tr class="separator:a5964fdb249fb43869c649198e13b727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1099605952f87fbdf59bc480a7a894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#aef1099605952f87fbdf59bc480a7a894">drawFastHLine</a> (int16_t x, int16_t y, int16_t w, uint16_t color)</td></tr>
<tr class="memdesc:aef1099605952f87fbdf59bc480a7a894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a horizontal line on the display. Self-contained and provides its own transaction as needed (see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a06312f906256fd7e72efb21df85d2b96" title="Draw a horizontal line on the display. Performs edge clipping and rejection. Not self-contained; shou...">writeFastHLine()</a> for a lower-level variant). Edge clipping and rejection is performed here.  <a href="#aef1099605952f87fbdf59bc480a7a894">More...</a><br /></td></tr>
<tr class="separator:aef1099605952f87fbdf59bc480a7a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bf597887f7098e55e7280d548bc127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ab9bf597887f7098e55e7280d548bc127">drawFastVLine</a> (int16_t x, int16_t y, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:ab9bf597887f7098e55e7280d548bc127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a vertical line on the display. Self-contained and provides its own transaction as needed (see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a06312f906256fd7e72efb21df85d2b96" title="Draw a horizontal line on the display. Performs edge clipping and rejection. Not self-contained; shou...">writeFastHLine()</a> for a lower- level variant). Edge clipping and rejection is performed here.  <a href="#ab9bf597887f7098e55e7280d548bc127">More...</a><br /></td></tr>
<tr class="separator:ab9bf597887f7098e55e7280d548bc127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b00726d150600cd8f0feb9a897fb64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a53b00726d150600cd8f0feb9a897fb64">pushColor</a> (uint16_t color)</td></tr>
<tr class="memdesc:a53b00726d150600cd8f0feb9a897fb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Essentially <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a795dcd9f5f850c057b0a896204fc7d55" title="Draw a single pixel to the display at requested coordinates. Not self-contained; should follow a star...">writePixel()</a> with a transaction around it. I don't think this is in use by any of our code anymore (believe it was for some older BMP-reading examples), but is kept here in case any user code relies on it. Consider it DEPRECATED.  <a href="#a53b00726d150600cd8f0feb9a897fb64">More...</a><br /></td></tr>
<tr class="separator:a53b00726d150600cd8f0feb9a897fb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2984b1d3854ed521259cd8208071b55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#aa2984b1d3854ed521259cd8208071b55">drawRGBBitmap</a> (int16_t x, int16_t y, uint16_t *pcolors, int16_t w, int16_t h)</td></tr>
<tr class="memdesc:aa2984b1d3854ed521259cd8208071b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 16-bit image (565 RGB) at the specified (x,y) position. For 16-bit display devices; no color reduction performed. Adapted from <a href="https://github.com/PaulStoffregen/ILI9341_t3">https://github.com/PaulStoffregen/ILI9341_t3</a> by Marc MERLIN. See examples/pictureEmbed to use this. 5/6/2017: function name and arguments have changed for compatibility with current GFX library and to avoid naming problems in prior implementation. Formerly <a class="el" href="class_adafruit___g_f_x.html#a805a15f1b3ea9eff5d1666b8e6db1c56" title="Draw a PROGMEM-resident 1-bit image at the specified (x,y) position, using the specified foreground c...">drawBitmap()</a> with arguments in different order. Handles its own transaction and edge clipping/rejection.  <a href="#aa2984b1d3854ed521259cd8208071b55">More...</a><br /></td></tr>
<tr class="separator:aa2984b1d3854ed521259cd8208071b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a13b3b0e6e0bb1328b5050559dd919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a21a13b3b0e6e0bb1328b5050559dd919">invertDisplay</a> (bool i)</td></tr>
<tr class="memdesc:a21a13b3b0e6e0bb1328b5050559dd919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the colors of the display (if supported by hardware). Self-contained, no transaction setup required.  <a href="#a21a13b3b0e6e0bb1328b5050559dd919">More...</a><br /></td></tr>
<tr class="separator:a21a13b3b0e6e0bb1328b5050559dd919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f04e5a60f1ff7cddc2934fa676b8b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a656f04e5a60f1ff7cddc2934fa676b8b">color565</a> (uint8_t r, uint8_t g, uint8_t b)</td></tr>
<tr class="memdesc:a656f04e5a60f1ff7cddc2934fa676b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given 8-bit red, green and blue values, return a 'packed' 16-bit color value in '565' RGB format (5 bits red, 6 bits green, 5 bits blue). This is just a mathematical operation, no hardware is touched.  <a href="#a656f04e5a60f1ff7cddc2934fa676b8b">More...</a><br /></td></tr>
<tr class="separator:a656f04e5a60f1ff7cddc2934fa676b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dfbee0ce62682988badc0dbbdc5790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a76dfbee0ce62682988badc0dbbdc5790">spiWrite</a> (uint8_t b)</td></tr>
<tr class="memdesc:a76dfbee0ce62682988badc0dbbdc5790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue a single 8-bit value to the display. Chip-select, transaction and data/command selection must have been previously set &ndash; this ONLY issues the byte. This is another of those functions in the library with a now-not-accurate name that's being maintained for compatibility with outside code. This function is used even if display connection is parallel.  <a href="#a76dfbee0ce62682988badc0dbbdc5790">More...</a><br /></td></tr>
<tr class="separator:a76dfbee0ce62682988badc0dbbdc5790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0169fcf8898413bba568a93c1617e8bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a0169fcf8898413bba568a93c1617e8bb">writeCommand</a> (uint8_t cmd)</td></tr>
<tr class="memdesc:a0169fcf8898413bba568a93c1617e8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single command byte to the display. Chip-select and transaction must have been previously set &ndash; this ONLY sets the device to COMMAND mode, issues the byte and then restores DATA mode. There is no corresponding explicit writeData() function &ndash; just use <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a76dfbee0ce62682988badc0dbbdc5790" title="Issue a single 8-bit value to the display. Chip-select, transaction and data/command selection must h...">spiWrite()</a>.  <a href="#a0169fcf8898413bba568a93c1617e8bb">More...</a><br /></td></tr>
<tr class="separator:a0169fcf8898413bba568a93c1617e8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6904156a9bb832fc510ae6df33e936e5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a6904156a9bb832fc510ae6df33e936e5">spiRead</a> (void)</td></tr>
<tr class="memdesc:a6904156a9bb832fc510ae6df33e936e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single 8-bit value from the display. Chip-select and transaction must have been previously set &ndash; this ONLY reads the byte. This is another of those functions in the library with a now-not-accurate name that's being maintained for compatibility with outside code. This function is used even if display connection is parallel.  <a href="#a6904156a9bb832fc510ae6df33e936e5">More...</a><br /></td></tr>
<tr class="separator:a6904156a9bb832fc510ae6df33e936e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d3977fd1a982a376cc4d98949d7269"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#af8d3977fd1a982a376cc4d98949d7269">SPI_WRITE16</a> (uint16_t w)</td></tr>
<tr class="memdesc:af8d3977fd1a982a376cc4d98949d7269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue a single 16-bit value to the display. Chip-select, transaction and data/command selection must have been previously set &ndash; this ONLY issues the word. Despite the name, this function is used even if display connection is parallel; name was maintaned for backward compatibility. Naming is also not consistent with the 8-bit version, <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a76dfbee0ce62682988badc0dbbdc5790" title="Issue a single 8-bit value to the display. Chip-select, transaction and data/command selection must h...">spiWrite()</a>. Sorry about that. Again, staying compatible with outside code.  <a href="#af8d3977fd1a982a376cc4d98949d7269">More...</a><br /></td></tr>
<tr class="separator:af8d3977fd1a982a376cc4d98949d7269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e8acadecd766abcb735e0e89c81149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a97e8acadecd766abcb735e0e89c81149">SPI_WRITE32</a> (uint32_t l)</td></tr>
<tr class="memdesc:a97e8acadecd766abcb735e0e89c81149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue a single 32-bit value to the display. Chip-select, transaction and data/command selection must have been previously set &ndash; this ONLY issues the longword. Despite the name, this function is used even if display connection is parallel; name was maintaned for backward compatibility. Naming is also not consistent with the 8-bit version, <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a76dfbee0ce62682988badc0dbbdc5790" title="Issue a single 8-bit value to the display. Chip-select, transaction and data/command selection must h...">spiWrite()</a>. Sorry about that. Again, staying compatible with outside code.  <a href="#a97e8acadecd766abcb735e0e89c81149">More...</a><br /></td></tr>
<tr class="separator:a97e8acadecd766abcb735e0e89c81149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab395bc0dca991a4b5151f459adf5ad38"><td class="memItemLeft" align="right" valign="top"><a id="ab395bc0dca991a4b5151f459adf5ad38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ab395bc0dca991a4b5151f459adf5ad38">SPI_CS_HIGH</a> (void)</td></tr>
<tr class="memdesc:ab395bc0dca991a4b5151f459adf5ad38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chip-select line HIGH. Does NOT check whether CS pin is set (&gt;=0), that should be handled in calling function. Despite function name, this is used even if the display connection is parallel. <br /></td></tr>
<tr class="separator:ab395bc0dca991a4b5151f459adf5ad38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb8eeea97e940e29cc124e155383f76"><td class="memItemLeft" align="right" valign="top"><a id="afbb8eeea97e940e29cc124e155383f76"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#afbb8eeea97e940e29cc124e155383f76">SPI_CS_LOW</a> (void)</td></tr>
<tr class="memdesc:afbb8eeea97e940e29cc124e155383f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chip-select line LOW. Does NOT check whether CS pin is set (&gt;=0), that should be handled in calling function. Despite function name, this is used even if the display connection is parallel. <br /></td></tr>
<tr class="separator:afbb8eeea97e940e29cc124e155383f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f7565d2b334770c75d8461dc675a7e"><td class="memItemLeft" align="right" valign="top"><a id="a94f7565d2b334770c75d8461dc675a7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a94f7565d2b334770c75d8461dc675a7e">SPI_DC_HIGH</a> (void)</td></tr>
<tr class="memdesc:a94f7565d2b334770c75d8461dc675a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data/command line HIGH (data mode). <br /></td></tr>
<tr class="separator:a94f7565d2b334770c75d8461dc675a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9765347ed3a7f645eefe521c2ed52a9"><td class="memItemLeft" align="right" valign="top"><a id="ac9765347ed3a7f645eefe521c2ed52a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ac9765347ed3a7f645eefe521c2ed52a9">SPI_DC_LOW</a> (void)</td></tr>
<tr class="memdesc:ac9765347ed3a7f645eefe521c2ed52a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data/command line LOW (command mode). <br /></td></tr>
<tr class="separator:ac9765347ed3a7f645eefe521c2ed52a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_adafruit___g_f_x"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_adafruit___g_f_x')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_adafruit___g_f_x.html">Adafruit_GFX</a></td></tr>
<tr class="memitem:a6f6f1abccf677eac244fa17d105133ea inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a6f6f1abccf677eac244fa17d105133ea">Adafruit_GFX</a> (int16_t w, int16_t h)</td></tr>
<tr class="memdesc:a6f6f1abccf677eac244fa17d105133ea inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instatiate a GFX context for graphics! Can only be done by a superclass.  <a href="class_adafruit___g_f_x.html#a6f6f1abccf677eac244fa17d105133ea">More...</a><br /></td></tr>
<tr class="separator:a6f6f1abccf677eac244fa17d105133ea inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e5204b9251a04a57c821f69a8e638b inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ae1e5204b9251a04a57c821f69a8e638b">writeLine</a> (int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color)</td></tr>
<tr class="memdesc:ae1e5204b9251a04a57c821f69a8e638b inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a line. Bresenham's algorithm - thx wikpedia.  <a href="class_adafruit___g_f_x.html#ae1e5204b9251a04a57c821f69a8e638b">More...</a><br /></td></tr>
<tr class="separator:ae1e5204b9251a04a57c821f69a8e638b inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac337c49876cee23ed062a928724675 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a6ac337c49876cee23ed062a928724675">setRotation</a> (uint8_t r)</td></tr>
<tr class="memdesc:a6ac337c49876cee23ed062a928724675 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set rotation setting for display.  <a href="class_adafruit___g_f_x.html#a6ac337c49876cee23ed062a928724675">More...</a><br /></td></tr>
<tr class="separator:a6ac337c49876cee23ed062a928724675 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa315803f39a5e73b1841874daf0483 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a2fa315803f39a5e73b1841874daf0483">invertDisplay</a> (boolean i)</td></tr>
<tr class="memdesc:a2fa315803f39a5e73b1841874daf0483 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the display (ideally using built-in hardware command)  <a href="class_adafruit___g_f_x.html#a2fa315803f39a5e73b1841874daf0483">More...</a><br /></td></tr>
<tr class="separator:a2fa315803f39a5e73b1841874daf0483 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d42e7cc577c1eb5b06fe656786c9c79 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a4d42e7cc577c1eb5b06fe656786c9c79">drawFastHLine</a> (int16_t x, int16_t y, int16_t w, uint16_t color)</td></tr>
<tr class="memdesc:a4d42e7cc577c1eb5b06fe656786c9c79 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a perfectly horizontal line (this is often optimized in a subclass!)  <a href="class_adafruit___g_f_x.html#a4d42e7cc577c1eb5b06fe656786c9c79">More...</a><br /></td></tr>
<tr class="separator:a4d42e7cc577c1eb5b06fe656786c9c79 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43cf1dfe6c17d040a0f1fd5ffbe9d69 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aa43cf1dfe6c17d040a0f1fd5ffbe9d69">fillRect</a> (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:aa43cf1dfe6c17d040a0f1fd5ffbe9d69 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rectangle completely with one color. Update in subclasses if desired!  <a href="class_adafruit___g_f_x.html#aa43cf1dfe6c17d040a0f1fd5ffbe9d69">More...</a><br /></td></tr>
<tr class="separator:aa43cf1dfe6c17d040a0f1fd5ffbe9d69 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2730aaf2208990928f9c0f85558527 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a2b2730aaf2208990928f9c0f85558527">fillScreen</a> (uint16_t color)</td></tr>
<tr class="memdesc:a2b2730aaf2208990928f9c0f85558527 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the screen completely with one color. Update in subclasses if desired!  <a href="class_adafruit___g_f_x.html#a2b2730aaf2208990928f9c0f85558527">More...</a><br /></td></tr>
<tr class="separator:a2b2730aaf2208990928f9c0f85558527 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ff662c2b2b48c3bac51f98c777776d inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aa0ff662c2b2b48c3bac51f98c777776d">drawLine</a> (int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color)</td></tr>
<tr class="memdesc:aa0ff662c2b2b48c3bac51f98c777776d inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a line.  <a href="class_adafruit___g_f_x.html#aa0ff662c2b2b48c3bac51f98c777776d">More...</a><br /></td></tr>
<tr class="separator:aa0ff662c2b2b48c3bac51f98c777776d inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2c2ab426503e4f7deddb93bb916f6 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a9ec2c2ab426503e4f7deddb93bb916f6">drawRect</a> (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:a9ec2c2ab426503e4f7deddb93bb916f6 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a rectangle with no fill color.  <a href="class_adafruit___g_f_x.html#a9ec2c2ab426503e4f7deddb93bb916f6">More...</a><br /></td></tr>
<tr class="separator:a9ec2c2ab426503e4f7deddb93bb916f6 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648d2d6765e488b4556e802167d885fb inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a648d2d6765e488b4556e802167d885fb">drawCircle</a> (int16_t x0, int16_t y0, int16_t r, uint16_t color)</td></tr>
<tr class="memdesc:a648d2d6765e488b4556e802167d885fb inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a circle outline.  <a href="class_adafruit___g_f_x.html#a648d2d6765e488b4556e802167d885fb">More...</a><br /></td></tr>
<tr class="separator:a648d2d6765e488b4556e802167d885fb inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2dd7b698e7b95ebf9fecf992ff802e inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a3f2dd7b698e7b95ebf9fecf992ff802e">drawCircleHelper</a> (int16_t x0, int16_t y0, int16_t r, uint8_t cornername, uint16_t color)</td></tr>
<tr class="memdesc:a3f2dd7b698e7b95ebf9fecf992ff802e inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quarter-circle drawer, used to do circles and roundrects.  <a href="class_adafruit___g_f_x.html#a3f2dd7b698e7b95ebf9fecf992ff802e">More...</a><br /></td></tr>
<tr class="separator:a3f2dd7b698e7b95ebf9fecf992ff802e inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623e031e58492fb41e9fde6a05d97c12 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a623e031e58492fb41e9fde6a05d97c12">fillCircle</a> (int16_t x0, int16_t y0, int16_t r, uint16_t color)</td></tr>
<tr class="memdesc:a623e031e58492fb41e9fde6a05d97c12 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a circle with filled color.  <a href="class_adafruit___g_f_x.html#a623e031e58492fb41e9fde6a05d97c12">More...</a><br /></td></tr>
<tr class="separator:a623e031e58492fb41e9fde6a05d97c12 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2242d3560b08c6480084152b6660052a inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a2242d3560b08c6480084152b6660052a">fillCircleHelper</a> (int16_t x0, int16_t y0, int16_t r, uint8_t cornername, int16_t delta, uint16_t color)</td></tr>
<tr class="memdesc:a2242d3560b08c6480084152b6660052a inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quarter-circle drawer with fill, used for circles and roundrects.  <a href="class_adafruit___g_f_x.html#a2242d3560b08c6480084152b6660052a">More...</a><br /></td></tr>
<tr class="separator:a2242d3560b08c6480084152b6660052a inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49284b9cea16ecf8c15dfd0b51a841e6 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a49284b9cea16ecf8c15dfd0b51a841e6">drawTriangle</a> (int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color)</td></tr>
<tr class="memdesc:a49284b9cea16ecf8c15dfd0b51a841e6 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a triangle with no fill color.  <a href="class_adafruit___g_f_x.html#a49284b9cea16ecf8c15dfd0b51a841e6">More...</a><br /></td></tr>
<tr class="separator:a49284b9cea16ecf8c15dfd0b51a841e6 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd646a3d9c9d5b3ee50010d0aa387cd inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a4cd646a3d9c9d5b3ee50010d0aa387cd">fillTriangle</a> (int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color)</td></tr>
<tr class="memdesc:a4cd646a3d9c9d5b3ee50010d0aa387cd inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a triangle with color-fill.  <a href="class_adafruit___g_f_x.html#a4cd646a3d9c9d5b3ee50010d0aa387cd">More...</a><br /></td></tr>
<tr class="separator:a4cd646a3d9c9d5b3ee50010d0aa387cd inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab496b247abec724ef80e17a30257972b inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ab496b247abec724ef80e17a30257972b">drawRoundRect</a> (int16_t x0, int16_t y0, int16_t w, int16_t h, int16_t radius, uint16_t color)</td></tr>
<tr class="memdesc:ab496b247abec724ef80e17a30257972b inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a rounded rectangle with no fill color.  <a href="class_adafruit___g_f_x.html#ab496b247abec724ef80e17a30257972b">More...</a><br /></td></tr>
<tr class="separator:ab496b247abec724ef80e17a30257972b inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dc59f6a508bcd3d5ac7af957b8b1ac inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a78dc59f6a508bcd3d5ac7af957b8b1ac">fillRoundRect</a> (int16_t x0, int16_t y0, int16_t w, int16_t h, int16_t radius, uint16_t color)</td></tr>
<tr class="memdesc:a78dc59f6a508bcd3d5ac7af957b8b1ac inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a rounded rectangle with fill color.  <a href="class_adafruit___g_f_x.html#a78dc59f6a508bcd3d5ac7af957b8b1ac">More...</a><br /></td></tr>
<tr class="separator:a78dc59f6a508bcd3d5ac7af957b8b1ac inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805a15f1b3ea9eff5d1666b8e6db1c56 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a805a15f1b3ea9eff5d1666b8e6db1c56">drawBitmap</a> (int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:a805a15f1b3ea9eff5d1666b8e6db1c56 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a PROGMEM-resident 1-bit image at the specified (x,y) position, using the specified foreground color (unset bits are transparent).  <a href="class_adafruit___g_f_x.html#a805a15f1b3ea9eff5d1666b8e6db1c56">More...</a><br /></td></tr>
<tr class="separator:a805a15f1b3ea9eff5d1666b8e6db1c56 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0def482cb5ab6010cac6936de8e07188 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a0def482cb5ab6010cac6936de8e07188">drawBitmap</a> (int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color, uint16_t bg)</td></tr>
<tr class="memdesc:a0def482cb5ab6010cac6936de8e07188 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a PROGMEM-resident 1-bit image at the specified (x,y) position, using the specified foreground (for set bits) and background (unset bits) colors.  <a href="class_adafruit___g_f_x.html#a0def482cb5ab6010cac6936de8e07188">More...</a><br /></td></tr>
<tr class="separator:a0def482cb5ab6010cac6936de8e07188 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957c2d2fc53e3121c5914a8bd9e5c3da inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a957c2d2fc53e3121c5914a8bd9e5c3da">drawBitmap</a> (int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:a957c2d2fc53e3121c5914a8bd9e5c3da inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a RAM-resident 1-bit image at the specified (x,y) position, using the specified foreground color (unset bits are transparent).  <a href="class_adafruit___g_f_x.html#a957c2d2fc53e3121c5914a8bd9e5c3da">More...</a><br /></td></tr>
<tr class="separator:a957c2d2fc53e3121c5914a8bd9e5c3da inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dfb7db5b7446406b9204c738f0885e inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a25dfb7db5b7446406b9204c738f0885e">drawBitmap</a> (int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h, uint16_t color, uint16_t bg)</td></tr>
<tr class="memdesc:a25dfb7db5b7446406b9204c738f0885e inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a RAM-resident 1-bit image at the specified (x,y) position, using the specified foreground (for set bits) and background (unset bits) colors.  <a href="class_adafruit___g_f_x.html#a25dfb7db5b7446406b9204c738f0885e">More...</a><br /></td></tr>
<tr class="separator:a25dfb7db5b7446406b9204c738f0885e inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7797117fef7d18592d352c14fa7d820 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aa7797117fef7d18592d352c14fa7d820">drawXBitmap</a> (int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color)</td></tr>
<tr class="memdesc:aa7797117fef7d18592d352c14fa7d820 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw PROGMEM-resident XBitMap Files (*.xbm), exported from GIMP. Usage: Export from GIMP to *.xbm, rename *.xbm to *.c and open in editor. C Array can be directly used with this function. There is no RAM-resident version of this function; if generating bitmaps in RAM, use the format defined by <a class="el" href="class_adafruit___g_f_x.html#a805a15f1b3ea9eff5d1666b8e6db1c56" title="Draw a PROGMEM-resident 1-bit image at the specified (x,y) position, using the specified foreground c...">drawBitmap()</a> and call that instead.  <a href="class_adafruit___g_f_x.html#aa7797117fef7d18592d352c14fa7d820">More...</a><br /></td></tr>
<tr class="separator:aa7797117fef7d18592d352c14fa7d820 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f146631268e8940d9c44c64c69ab80 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#af7f146631268e8940d9c44c64c69ab80">drawGrayscaleBitmap</a> (int16_t x, int16_t y, const uint8_t bitmap[], int16_t w, int16_t h)</td></tr>
<tr class="memdesc:af7f146631268e8940d9c44c64c69ab80 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a PROGMEM-resident 8-bit image (grayscale) at the specified (x,y) pos. Specifically for 8-bit display devices such as IS31FL3731; no color reduction/expansion is performed.  <a href="class_adafruit___g_f_x.html#af7f146631268e8940d9c44c64c69ab80">More...</a><br /></td></tr>
<tr class="separator:af7f146631268e8940d9c44c64c69ab80 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b26b1e2ac05476fdbd44214001954d inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a00b26b1e2ac05476fdbd44214001954d">drawGrayscaleBitmap</a> (int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h)</td></tr>
<tr class="memdesc:a00b26b1e2ac05476fdbd44214001954d inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a RAM-resident 8-bit image (grayscale) at the specified (x,y) pos. Specifically for 8-bit display devices such as IS31FL3731; no color reduction/expansion is performed.  <a href="class_adafruit___g_f_x.html#a00b26b1e2ac05476fdbd44214001954d">More...</a><br /></td></tr>
<tr class="separator:a00b26b1e2ac05476fdbd44214001954d inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b422ce35d0e3956dcd00638a421e4 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a880b422ce35d0e3956dcd00638a421e4">drawGrayscaleBitmap</a> (int16_t x, int16_t y, const uint8_t bitmap[], const uint8_t mask[], int16_t w, int16_t h)</td></tr>
<tr class="memdesc:a880b422ce35d0e3956dcd00638a421e4 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a PROGMEM-resident 8-bit image (grayscale) with a 1-bit mask (set bits = opaque, unset bits = clear) at the specified (x,y) position. BOTH buffers (grayscale and mask) must be PROGMEM-resident. Specifically for 8-bit display devices such as IS31FL3731; no color reduction/expansion is performed.  <a href="class_adafruit___g_f_x.html#a880b422ce35d0e3956dcd00638a421e4">More...</a><br /></td></tr>
<tr class="separator:a880b422ce35d0e3956dcd00638a421e4 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7543eee2c983daea5eb46a0c2db92692 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a7543eee2c983daea5eb46a0c2db92692">drawGrayscaleBitmap</a> (int16_t x, int16_t y, uint8_t *bitmap, uint8_t *mask, int16_t w, int16_t h)</td></tr>
<tr class="memdesc:a7543eee2c983daea5eb46a0c2db92692 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a RAM-resident 8-bit image (grayscale) with a 1-bit mask (set bits = opaque, unset bits = clear) at the specified (x,y) position. BOTH buffers (grayscale and mask) must be RAM-residentt, no mix-and-match Specifically for 8-bit display devices such as IS31FL3731; no color reduction/expansion is performed.  <a href="class_adafruit___g_f_x.html#a7543eee2c983daea5eb46a0c2db92692">More...</a><br /></td></tr>
<tr class="separator:a7543eee2c983daea5eb46a0c2db92692 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e317367f3ac6dae3aa46d549ca535 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#af90e317367f3ac6dae3aa46d549ca535">drawRGBBitmap</a> (int16_t x, int16_t y, const uint16_t bitmap[], int16_t w, int16_t h)</td></tr>
<tr class="memdesc:af90e317367f3ac6dae3aa46d549ca535 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a PROGMEM-resident 16-bit image (RGB 5/6/5) at the specified (x,y) position. For 16-bit display devices; no color reduction performed.  <a href="class_adafruit___g_f_x.html#af90e317367f3ac6dae3aa46d549ca535">More...</a><br /></td></tr>
<tr class="separator:af90e317367f3ac6dae3aa46d549ca535 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70768127ee8548d2a3690440c1694169 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a70768127ee8548d2a3690440c1694169">drawRGBBitmap</a> (int16_t x, int16_t y, uint16_t *bitmap, int16_t w, int16_t h)</td></tr>
<tr class="memdesc:a70768127ee8548d2a3690440c1694169 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a RAM-resident 16-bit image (RGB 5/6/5) at the specified (x,y) position. For 16-bit display devices; no color reduction performed.  <a href="class_adafruit___g_f_x.html#a70768127ee8548d2a3690440c1694169">More...</a><br /></td></tr>
<tr class="separator:a70768127ee8548d2a3690440c1694169 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d249d742f83ddc4c4f3867643d6eb0 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ad1d249d742f83ddc4c4f3867643d6eb0">drawRGBBitmap</a> (int16_t x, int16_t y, const uint16_t bitmap[], const uint8_t mask[], int16_t w, int16_t h)</td></tr>
<tr class="memdesc:ad1d249d742f83ddc4c4f3867643d6eb0 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a PROGMEM-resident 16-bit image (RGB 5/6/5) with a 1-bit mask (set bits = opaque, unset bits = clear) at the specified (x,y) position. BOTH buffers (color and mask) must be PROGMEM-resident. For 16-bit display devices; no color reduction performed.  <a href="class_adafruit___g_f_x.html#ad1d249d742f83ddc4c4f3867643d6eb0">More...</a><br /></td></tr>
<tr class="separator:ad1d249d742f83ddc4c4f3867643d6eb0 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6f64d394f8d3557aa6f613b4219866 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aac6f64d394f8d3557aa6f613b4219866">drawRGBBitmap</a> (int16_t x, int16_t y, uint16_t *bitmap, uint8_t *mask, int16_t w, int16_t h)</td></tr>
<tr class="memdesc:aac6f64d394f8d3557aa6f613b4219866 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a RAM-resident 16-bit image (RGB 5/6/5) with a 1-bit mask (set bits = opaque, unset bits = clear) at the specified (x,y) position. BOTH buffers (color and mask) must be RAM-resident. For 16-bit display devices; no color reduction performed.  <a href="class_adafruit___g_f_x.html#aac6f64d394f8d3557aa6f613b4219866">More...</a><br /></td></tr>
<tr class="separator:aac6f64d394f8d3557aa6f613b4219866 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f5a29b3a3dffe30c6a3f4c1f604a5a inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ab7f5a29b3a3dffe30c6a3f4c1f604a5a">drawChar</a> (int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size)</td></tr>
<tr class="memdesc:ab7f5a29b3a3dffe30c6a3f4c1f604a5a inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single character.  <a href="class_adafruit___g_f_x.html#ab7f5a29b3a3dffe30c6a3f4c1f604a5a">More...</a><br /></td></tr>
<tr class="separator:ab7f5a29b3a3dffe30c6a3f4c1f604a5a inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ee1ead075d0e87c34116f917a5f06b inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aa6ee1ead075d0e87c34116f917a5f06b">drawChar</a> (int16_t x, int16_t y, unsigned char c, uint16_t color, uint16_t bg, uint8_t size_x, uint8_t size_y)</td></tr>
<tr class="memdesc:aa6ee1ead075d0e87c34116f917a5f06b inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single character.  <a href="class_adafruit___g_f_x.html#aa6ee1ead075d0e87c34116f917a5f06b">More...</a><br /></td></tr>
<tr class="separator:aa6ee1ead075d0e87c34116f917a5f06b inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90983ed41807de26d48bcf588d7c9a19 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a90983ed41807de26d48bcf588d7c9a19">getTextBounds</a> (const char *string, int16_t x, int16_t y, int16_t *x1, int16_t *y1, uint16_t *w, uint16_t *h)</td></tr>
<tr class="memdesc:a90983ed41807de26d48bcf588d7c9a19 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine size of a string with current font/size. Pass string and a cursor position, returns UL corner and W,H.  <a href="class_adafruit___g_f_x.html#a90983ed41807de26d48bcf588d7c9a19">More...</a><br /></td></tr>
<tr class="separator:a90983ed41807de26d48bcf588d7c9a19 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97525abb71dbe38c6551e4d0da4052b8 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a97525abb71dbe38c6551e4d0da4052b8">getTextBounds</a> (const __FlashStringHelper *s, int16_t x, int16_t y, int16_t *x1, int16_t *y1, uint16_t *w, uint16_t *h)</td></tr>
<tr class="memdesc:a97525abb71dbe38c6551e4d0da4052b8 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine size of a PROGMEM string with current font/size. Pass string and a cursor position, returns UL corner and W,H.  <a href="class_adafruit___g_f_x.html#a97525abb71dbe38c6551e4d0da4052b8">More...</a><br /></td></tr>
<tr class="separator:a97525abb71dbe38c6551e4d0da4052b8 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4258c8e7e5e897a3e5e87748e4585579 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a4258c8e7e5e897a3e5e87748e4585579">getTextBounds</a> (const String &amp;str, int16_t x, int16_t y, int16_t *x1, int16_t *y1, uint16_t *w, uint16_t *h)</td></tr>
<tr class="memdesc:a4258c8e7e5e897a3e5e87748e4585579 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine size of a string with current font/size. Pass string and a cursor position, returns UL corner and W,H.  <a href="class_adafruit___g_f_x.html#a4258c8e7e5e897a3e5e87748e4585579">More...</a><br /></td></tr>
<tr class="separator:a4258c8e7e5e897a3e5e87748e4585579 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eb4a8a2c9fa4ab7d58ceffd19535d5 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a39eb4a8a2c9fa4ab7d58ceffd19535d5">setTextSize</a> (uint8_t s)</td></tr>
<tr class="memdesc:a39eb4a8a2c9fa4ab7d58ceffd19535d5 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set text 'magnification' size. Each increase in s makes 1 pixel that much bigger.  <a href="class_adafruit___g_f_x.html#a39eb4a8a2c9fa4ab7d58ceffd19535d5">More...</a><br /></td></tr>
<tr class="separator:a39eb4a8a2c9fa4ab7d58ceffd19535d5 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8ea7d9203db38d7b601979f1252e37 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#abd8ea7d9203db38d7b601979f1252e37">setTextSize</a> (uint8_t sx, uint8_t sy)</td></tr>
<tr class="memdesc:abd8ea7d9203db38d7b601979f1252e37 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set text 'magnification' size. Each increase in s makes 1 pixel that much bigger.  <a href="class_adafruit___g_f_x.html#abd8ea7d9203db38d7b601979f1252e37">More...</a><br /></td></tr>
<tr class="separator:abd8ea7d9203db38d7b601979f1252e37 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0479a2bb4e09e7c39c35e35c55d6ed1 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ab0479a2bb4e09e7c39c35e35c55d6ed1">setFont</a> (const <a class="el" href="struct_g_f_xfont.html">GFXfont</a> *f=NULL)</td></tr>
<tr class="memdesc:ab0479a2bb4e09e7c39c35e35c55d6ed1 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the font to display when print()ing, either custom or default.  <a href="class_adafruit___g_f_x.html#ab0479a2bb4e09e7c39c35e35c55d6ed1">More...</a><br /></td></tr>
<tr class="separator:ab0479a2bb4e09e7c39c35e35c55d6ed1 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf96a40cad0f34dd8ec73494b3866c33 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aaf96a40cad0f34dd8ec73494b3866c33">setCursor</a> (int16_t x, int16_t y)</td></tr>
<tr class="memdesc:aaf96a40cad0f34dd8ec73494b3866c33 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set text cursor location.  <a href="class_adafruit___g_f_x.html#aaf96a40cad0f34dd8ec73494b3866c33">More...</a><br /></td></tr>
<tr class="separator:aaf96a40cad0f34dd8ec73494b3866c33 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59178a0e0c845a14a39b457c43567dd9 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a59178a0e0c845a14a39b457c43567dd9">setTextColor</a> (uint16_t c)</td></tr>
<tr class="memdesc:a59178a0e0c845a14a39b457c43567dd9 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set text font color with transparant background.  <a href="class_adafruit___g_f_x.html#a59178a0e0c845a14a39b457c43567dd9">More...</a><br /></td></tr>
<tr class="separator:a59178a0e0c845a14a39b457c43567dd9 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e88c585d3ab6b4f95199361f224fc6 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ab6e88c585d3ab6b4f95199361f224fc6">setTextColor</a> (uint16_t c, uint16_t bg)</td></tr>
<tr class="memdesc:ab6e88c585d3ab6b4f95199361f224fc6 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set text font color with custom background color.  <a href="class_adafruit___g_f_x.html#ab6e88c585d3ab6b4f95199361f224fc6">More...</a><br /></td></tr>
<tr class="separator:ab6e88c585d3ab6b4f95199361f224fc6 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeacd62bf26f3e7abbdc4b5b50faa6fa inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aeeacd62bf26f3e7abbdc4b5b50faa6fa">setTextWrap</a> (boolean w)</td></tr>
<tr class="memdesc:aeeacd62bf26f3e7abbdc4b5b50faa6fa inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether text that is too long for the screen width should automatically wrap around to the next line (else clip right).  <a href="class_adafruit___g_f_x.html#aeeacd62bf26f3e7abbdc4b5b50faa6fa">More...</a><br /></td></tr>
<tr class="separator:aeeacd62bf26f3e7abbdc4b5b50faa6fa inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d447fe274e3f0ff12f12afa538d0afe inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a6d447fe274e3f0ff12f12afa538d0afe">cp437</a> (boolean x=true)</td></tr>
<tr class="memdesc:a6d447fe274e3f0ff12f12afa538d0afe inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable (or disable) Code Page 437-compatible charset. There was an error in glcdfont.c for the longest time &ndash; one character (#176, the 'light shade' block) was missing &ndash; this threw off the index of every character that followed it. But a TON of code has been written with the erroneous character indices. By default, the library uses the original 'wrong' behavior and old sketches will still work. Pass 'true' to this function to use correct CP437 character values in your code.  <a href="class_adafruit___g_f_x.html#a6d447fe274e3f0ff12f12afa538d0afe">More...</a><br /></td></tr>
<tr class="separator:a6d447fe274e3f0ff12f12afa538d0afe inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8773d92cafa93d3f749fb55c535d8f2e inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a8773d92cafa93d3f749fb55c535d8f2e">write</a> (uint8_t)</td></tr>
<tr class="memdesc:a8773d92cafa93d3f749fb55c535d8f2e inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print one byte/character of data, used to support print()  <a href="class_adafruit___g_f_x.html#a8773d92cafa93d3f749fb55c535d8f2e">More...</a><br /></td></tr>
<tr class="separator:a8773d92cafa93d3f749fb55c535d8f2e inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b5361e7198ef0e79eaf4c80bddfc7 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a324b5361e7198ef0e79eaf4c80bddfc7">width</a> (void) const</td></tr>
<tr class="memdesc:a324b5361e7198ef0e79eaf4c80bddfc7 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get width of the display, accounting for current rotation.  <a href="class_adafruit___g_f_x.html#a324b5361e7198ef0e79eaf4c80bddfc7">More...</a><br /></td></tr>
<tr class="separator:a324b5361e7198ef0e79eaf4c80bddfc7 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49da524caa19e5202ed2ed7fd5a3baea inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a49da524caa19e5202ed2ed7fd5a3baea">height</a> (void) const</td></tr>
<tr class="memdesc:a49da524caa19e5202ed2ed7fd5a3baea inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get height of the display, accounting for current rotation.  <a href="class_adafruit___g_f_x.html#a49da524caa19e5202ed2ed7fd5a3baea">More...</a><br /></td></tr>
<tr class="separator:a49da524caa19e5202ed2ed7fd5a3baea inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90e1378511b93189a7b557d7dda5d73 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ab90e1378511b93189a7b557d7dda5d73">getRotation</a> (void) const</td></tr>
<tr class="memdesc:ab90e1378511b93189a7b557d7dda5d73 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rotation setting for display.  <a href="class_adafruit___g_f_x.html#ab90e1378511b93189a7b557d7dda5d73">More...</a><br /></td></tr>
<tr class="separator:ab90e1378511b93189a7b557d7dda5d73 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1d15f5f15cad95b4c20f0e9ac9c74b inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a0d1d15f5f15cad95b4c20f0e9ac9c74b">getCursorX</a> (void) const</td></tr>
<tr class="memdesc:a0d1d15f5f15cad95b4c20f0e9ac9c74b inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get text cursor X location.  <a href="class_adafruit___g_f_x.html#a0d1d15f5f15cad95b4c20f0e9ac9c74b">More...</a><br /></td></tr>
<tr class="separator:a0d1d15f5f15cad95b4c20f0e9ac9c74b inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c8558cfcb717c4cfbd5475998daed1 inherit pub_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a81c8558cfcb717c4cfbd5475998daed1">getCursorY</a> (void) const</td></tr>
<tr class="memdesc:a81c8558cfcb717c4cfbd5475998daed1 inherit pub_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get text cursor Y location.  <a href="class_adafruit___g_f_x.html#a81c8558cfcb717c4cfbd5475998daed1">More...</a><br /></td></tr>
<tr class="separator:a81c8558cfcb717c4cfbd5475998daed1 inherit pub_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a88f3c607cb9a5bd1d7f55881a1f3dc95"><td class="memItemLeft" align="right" valign="top"><a id="a88f3c607cb9a5bd1d7f55881a1f3dc95"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a88f3c607cb9a5bd1d7f55881a1f3dc95">SPI_MOSI_HIGH</a> (void)</td></tr>
<tr class="memdesc:a88f3c607cb9a5bd1d7f55881a1f3dc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the software (bitbang) SPI MOSI line HIGH. <br /></td></tr>
<tr class="separator:a88f3c607cb9a5bd1d7f55881a1f3dc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0093ed5cdb3302761df4633cc065b06a"><td class="memItemLeft" align="right" valign="top"><a id="a0093ed5cdb3302761df4633cc065b06a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a0093ed5cdb3302761df4633cc065b06a">SPI_MOSI_LOW</a> (void)</td></tr>
<tr class="memdesc:a0093ed5cdb3302761df4633cc065b06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the software (bitbang) SPI MOSI line LOW. <br /></td></tr>
<tr class="separator:a0093ed5cdb3302761df4633cc065b06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d68df2a27c46a4ed1737d471d05af3f"><td class="memItemLeft" align="right" valign="top"><a id="a0d68df2a27c46a4ed1737d471d05af3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a0d68df2a27c46a4ed1737d471d05af3f">SPI_SCK_HIGH</a> (void)</td></tr>
<tr class="memdesc:a0d68df2a27c46a4ed1737d471d05af3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the software (bitbang) SPI SCK line HIGH. <br /></td></tr>
<tr class="separator:a0d68df2a27c46a4ed1737d471d05af3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6a3043e2f5813d21db7ffb168955a8"><td class="memItemLeft" align="right" valign="top"><a id="a0e6a3043e2f5813d21db7ffb168955a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a0e6a3043e2f5813d21db7ffb168955a8">SPI_SCK_LOW</a> (void)</td></tr>
<tr class="memdesc:a0e6a3043e2f5813d21db7ffb168955a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the software (bitbang) SPI SCK line LOW. <br /></td></tr>
<tr class="separator:a0e6a3043e2f5813d21db7ffb168955a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4982ab4b15c7b3bc30c553e1abf279"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a9d4982ab4b15c7b3bc30c553e1abf279">SPI_MISO_READ</a> (void)</td></tr>
<tr class="memdesc:a9d4982ab4b15c7b3bc30c553e1abf279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the state of the software (bitbang) SPI MISO line.  <a href="#a9d4982ab4b15c7b3bc30c553e1abf279">More...</a><br /></td></tr>
<tr class="separator:a9d4982ab4b15c7b3bc30c553e1abf279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb38cd7e43e128cf47b1f456423bea33"><td class="memItemLeft" align="right" valign="top"><a id="adb38cd7e43e128cf47b1f456423bea33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#adb38cd7e43e128cf47b1f456423bea33">SPI_BEGIN_TRANSACTION</a> (void)</td></tr>
<tr class="memdesc:adb38cd7e43e128cf47b1f456423bea33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an SPI transaction if using the hardware SPI interface to the display. If using an earlier version of the Arduino platform (before the addition of SPI transactions), this instead attempts to set up the SPI clock and mode. No action is taken if the connection is not hardware SPI-based. This does NOT include a chip-select operation &ndash; see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a> for a function that encapsulated both actions. <br /></td></tr>
<tr class="separator:adb38cd7e43e128cf47b1f456423bea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e8221c57511c40c9f53b7b455252ab"><td class="memItemLeft" align="right" valign="top"><a id="a52e8221c57511c40c9f53b7b455252ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a52e8221c57511c40c9f53b7b455252ab">SPI_END_TRANSACTION</a> (void)</td></tr>
<tr class="memdesc:a52e8221c57511c40c9f53b7b455252ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">End an SPI transaction if using the hardware SPI interface to the display. No action is taken if the connection is not hardware SPI-based or if using an earlier version of the Arduino platform (before the addition of SPI transactions). This does NOT include a chip-deselect operation &ndash; see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a65f00bcb36ed34e9f8fb72d45c6d0cad" title="Call after issuing command(s) or data to display. Performs chip-deselect (if required) and ends an SP...">endWrite()</a> for a function that encapsulated both actions. <br /></td></tr>
<tr class="separator:a52e8221c57511c40c9f53b7b455252ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59285824eb5a042a2169edc127b2551"><td class="memItemLeft" align="right" valign="top"><a id="ab59285824eb5a042a2169edc127b2551"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ab59285824eb5a042a2169edc127b2551">TFT_WR_STROBE</a> (void)</td></tr>
<tr class="memdesc:ab59285824eb5a042a2169edc127b2551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the WR line LOW, then HIGH. Used for parallel-connected interfaces when writing data. <br /></td></tr>
<tr class="separator:ab59285824eb5a042a2169edc127b2551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bfd459e24a52d990c238435a5f9b3e"><td class="memItemLeft" align="right" valign="top"><a id="ad7bfd459e24a52d990c238435a5f9b3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad7bfd459e24a52d990c238435a5f9b3e">TFT_RD_HIGH</a> (void)</td></tr>
<tr class="memdesc:ad7bfd459e24a52d990c238435a5f9b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RD line HIGH. Used for parallel-connected interfaces when reading data. <br /></td></tr>
<tr class="separator:ad7bfd459e24a52d990c238435a5f9b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12271a88164e8050ad349fda34dce02d"><td class="memItemLeft" align="right" valign="top"><a id="a12271a88164e8050ad349fda34dce02d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a12271a88164e8050ad349fda34dce02d">TFT_RD_LOW</a> (void)</td></tr>
<tr class="memdesc:a12271a88164e8050ad349fda34dce02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RD line LOW. Used for parallel-connected interfaces when reading data. <br /></td></tr>
<tr class="separator:a12271a88164e8050ad349fda34dce02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_adafruit___g_f_x"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_adafruit___g_f_x')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_adafruit___g_f_x.html">Adafruit_GFX</a></td></tr>
<tr class="memitem:a21c19ed786f8291613d082e81ad4e3c4 inherit pro_methods_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a21c19ed786f8291613d082e81ad4e3c4">charBounds</a> (char c, int16_t *x, int16_t *y, int16_t *minx, int16_t *miny, int16_t *maxx, int16_t *maxy)</td></tr>
<tr class="memdesc:a21c19ed786f8291613d082e81ad4e3c4 inherit pro_methods_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine size of a character with current font/size. Broke this out as it's used by both the PROGMEM- and RAM-resident <a class="el" href="class_adafruit___g_f_x.html#a90983ed41807de26d48bcf588d7c9a19" title="Helper to determine size of a string with current font/size. Pass string and a cursor position...">getTextBounds()</a> functions.  <a href="class_adafruit___g_f_x.html#a21c19ed786f8291613d082e81ad4e3c4">More...</a><br /></td></tr>
<tr class="separator:a21c19ed786f8291613d082e81ad4e3c4 inherit pro_methods_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5f2a2b125cc4b5b1d643f81c34e67cab"><td class="memItemLeft" ><a id="a5f2a2b125cc4b5b1d643f81c34e67cab"></a>
struct {</td></tr>
<tr class="memitem:a5c956cdfee25309fec4addcfce845260"><td class="memItemLeft" >
&#160;&#160;&#160;SPIClass *&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#a2003f65628bfcd075b300f022dce0ffc">_spi</a></td></tr>
<tr class="memdesc:a5c956cdfee25309fec4addcfce845260"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI class pointer. <br /></td></tr>
<tr class="separator:a5c956cdfee25309fec4addcfce845260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0614bdfc3c92188f24764f414026f02"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#a65e9eb00f665cadb411babf9c506a01d">_freq</a></td></tr>
<tr class="memdesc:af0614bdfc3c92188f24764f414026f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI bitrate (if no SPI transactions) <br /></td></tr>
<tr class="separator:af0614bdfc3c92188f24764f414026f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5094f83bc05d3e8fe3bea99c23ff19e0"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#a78479cba8923b3d1c59b104359d71904">_mode</a></td></tr>
<tr class="memdesc:a5094f83bc05d3e8fe3bea99c23ff19e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI data mode (transactions or no) <br /></td></tr>
<tr class="separator:a5094f83bc05d3e8fe3bea99c23ff19e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2a2b125cc4b5b1d643f81c34e67cab"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a5f2a2b125cc4b5b1d643f81c34e67cab">hwspi</a></td></tr>
<tr class="memdesc:a5f2a2b125cc4b5b1d643f81c34e67cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware SPI values. <br /></td></tr>
<tr class="separator:a5f2a2b125cc4b5b1d643f81c34e67cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2d14887d6e0c55bb30eda76f3aa15b"><td class="memItemLeft" ><a id="a3a2d14887d6e0c55bb30eda76f3aa15b"></a>
struct {</td></tr>
<tr class="memitem:addecfd3946c0e416d2d061249a870c7d"><td class="memItemLeft" >
&#160;&#160;&#160;int8_t&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#a02d06f8d1fbe420c6dca776f636a41e5">_mosi</a></td></tr>
<tr class="memdesc:addecfd3946c0e416d2d061249a870c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">MOSI pin #. <br /></td></tr>
<tr class="separator:addecfd3946c0e416d2d061249a870c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a659a45b295166980c61c92d2c993f"><td class="memItemLeft" >
&#160;&#160;&#160;int8_t&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#a19f9a2a73ad817b16cd8c73556138363">_miso</a></td></tr>
<tr class="memdesc:a18a659a45b295166980c61c92d2c993f"><td class="mdescLeft">&#160;</td><td class="mdescRight">MISO pin #. <br /></td></tr>
<tr class="separator:a18a659a45b295166980c61c92d2c993f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac877a5b3620e1dd9fb9329db2ab8e0d7"><td class="memItemLeft" >
&#160;&#160;&#160;int8_t&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#afd793c2ed96f6ac9e653a1bf67fda921">_sck</a></td></tr>
<tr class="memdesc:ac877a5b3620e1dd9fb9329db2ab8e0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCK pin #. <br /></td></tr>
<tr class="separator:ac877a5b3620e1dd9fb9329db2ab8e0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2d14887d6e0c55bb30eda76f3aa15b"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a3a2d14887d6e0c55bb30eda76f3aa15b">swspi</a></td></tr>
<tr class="memdesc:a3a2d14887d6e0c55bb30eda76f3aa15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software SPI values. <br /></td></tr>
<tr class="separator:a3a2d14887d6e0c55bb30eda76f3aa15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e31d8fcece00ed7bb2950efc5270e2"><td class="memItemLeft" ><a id="a76e31d8fcece00ed7bb2950efc5270e2"></a>
struct {</td></tr>
<tr class="memitem:a9a4b77dd76ca87353a7726086eead2cb"><td class="memItemLeft" >
&#160;&#160;&#160;int8_t&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#a5b26872a4e2b08017b475e9a542261cb">_d0</a></td></tr>
<tr class="memdesc:a9a4b77dd76ca87353a7726086eead2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data pin 0 #. <br /></td></tr>
<tr class="separator:a9a4b77dd76ca87353a7726086eead2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be43dc4b896a5582d62739d04eb9fc4"><td class="memItemLeft" >
&#160;&#160;&#160;int8_t&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#a87971f3f0f04e8099d54be48995cb578">_wr</a></td></tr>
<tr class="memdesc:a6be43dc4b896a5582d62739d04eb9fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write strobe pin #. <br /></td></tr>
<tr class="separator:a6be43dc4b896a5582d62739d04eb9fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbf5011a85fa31cd7c9ac137d923ad6"><td class="memItemLeft" >
&#160;&#160;&#160;int8_t&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#a46b1c645935c1163dbad553adbdabff7">_rd</a></td></tr>
<tr class="memdesc:a3fbf5011a85fa31cd7c9ac137d923ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read strobe pin # (or -1) <br /></td></tr>
<tr class="separator:a3fbf5011a85fa31cd7c9ac137d923ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22983e4d102b95f45050ef3480ba45b"><td class="memItemLeft" >
&#160;&#160;&#160;bool&#160;&#160;&#160;<a class="el" href="class_adafruit___s_p_i_t_f_t.html#ab49cda19025e4f18f65f1a00ce65693d">wide</a> = 0</td></tr>
<tr class="memdesc:ab22983e4d102b95f45050ef3480ba45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, is 16-bit interface. <br /></td></tr>
<tr class="separator:ab22983e4d102b95f45050ef3480ba45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e31d8fcece00ed7bb2950efc5270e2"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a76e31d8fcece00ed7bb2950efc5270e2">tft8</a></td></tr>
<tr class="memdesc:a76e31d8fcece00ed7bb2950efc5270e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel interface settings. <br /></td></tr>
<tr class="separator:a76e31d8fcece00ed7bb2950efc5270e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17cc84566e35b026f8b6f38903be80b"><td class="memItemLeft" align="right" valign="top"><a id="ae17cc84566e35b026f8b6f38903be80b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ae17cc84566e35b026f8b6f38903be80b">connection</a></td></tr>
<tr class="memdesc:ae17cc84566e35b026f8b6f38903be80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TFT_HARD_SPI, TFT_SOFT_SPI, etc. <br /></td></tr>
<tr class="separator:ae17cc84566e35b026f8b6f38903be80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534eb433f9084d1e5b8088964a617a8a"><td class="memItemLeft" align="right" valign="top"><a id="a534eb433f9084d1e5b8088964a617a8a"></a>
int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a534eb433f9084d1e5b8088964a617a8a">_rst</a></td></tr>
<tr class="memdesc:a534eb433f9084d1e5b8088964a617a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset pin # (or -1) <br /></td></tr>
<tr class="separator:a534eb433f9084d1e5b8088964a617a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ed6886fcef09bd3d98a02238ae7300"><td class="memItemLeft" align="right" valign="top"><a id="ac0ed6886fcef09bd3d98a02238ae7300"></a>
int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ac0ed6886fcef09bd3d98a02238ae7300">_cs</a></td></tr>
<tr class="memdesc:ac0ed6886fcef09bd3d98a02238ae7300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chip select pin # (or -1) <br /></td></tr>
<tr class="separator:ac0ed6886fcef09bd3d98a02238ae7300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154f060e2830dc7096af9d0b6022d12a"><td class="memItemLeft" align="right" valign="top"><a id="a154f060e2830dc7096af9d0b6022d12a"></a>
int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a154f060e2830dc7096af9d0b6022d12a">_dc</a></td></tr>
<tr class="memdesc:a154f060e2830dc7096af9d0b6022d12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data/command pin #. <br /></td></tr>
<tr class="separator:a154f060e2830dc7096af9d0b6022d12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479fb9af838dc94c442b27c734dab345"><td class="memItemLeft" align="right" valign="top"><a id="a479fb9af838dc94c442b27c734dab345"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a479fb9af838dc94c442b27c734dab345">_xstart</a> = 0</td></tr>
<tr class="memdesc:a479fb9af838dc94c442b27c734dab345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal framebuffer X offset. <br /></td></tr>
<tr class="separator:a479fb9af838dc94c442b27c734dab345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1d3250b346656552dfdf939b1e428d"><td class="memItemLeft" align="right" valign="top"><a id="a1b1d3250b346656552dfdf939b1e428d"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a1b1d3250b346656552dfdf939b1e428d">_ystart</a> = 0</td></tr>
<tr class="memdesc:a1b1d3250b346656552dfdf939b1e428d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal framebuffer Y offset. <br /></td></tr>
<tr class="separator:a1b1d3250b346656552dfdf939b1e428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d068ec372f9ffa2a6a451542634bc1"><td class="memItemLeft" align="right" valign="top"><a id="ad6d068ec372f9ffa2a6a451542634bc1"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad6d068ec372f9ffa2a6a451542634bc1">invertOnCommand</a> = 0</td></tr>
<tr class="memdesc:ad6d068ec372f9ffa2a6a451542634bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command to enable invert mode. <br /></td></tr>
<tr class="separator:ad6d068ec372f9ffa2a6a451542634bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7248ddde9f18b64675139cea13998141"><td class="memItemLeft" align="right" valign="top"><a id="a7248ddde9f18b64675139cea13998141"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___s_p_i_t_f_t.html#a7248ddde9f18b64675139cea13998141">invertOffCommand</a> = 0</td></tr>
<tr class="memdesc:a7248ddde9f18b64675139cea13998141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command to disable invert mode. <br /></td></tr>
<tr class="separator:a7248ddde9f18b64675139cea13998141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_adafruit___g_f_x"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_adafruit___g_f_x')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_adafruit___g_f_x.html">Adafruit_GFX</a></td></tr>
<tr class="memitem:aded338777abeac3c457660023f5c0724 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="aded338777abeac3c457660023f5c0724"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aded338777abeac3c457660023f5c0724">WIDTH</a></td></tr>
<tr class="memdesc:aded338777abeac3c457660023f5c0724 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the 'raw' display width - never changes. <br /></td></tr>
<tr class="separator:aded338777abeac3c457660023f5c0724 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7801fc9c405a61abe6e5916b55825b inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="a2b7801fc9c405a61abe6e5916b55825b"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a2b7801fc9c405a61abe6e5916b55825b">HEIGHT</a></td></tr>
<tr class="memdesc:a2b7801fc9c405a61abe6e5916b55825b inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the 'raw' display height - never changes. <br /></td></tr>
<tr class="separator:a2b7801fc9c405a61abe6e5916b55825b inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab237f850a033492f5e745d79405a097a inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="ab237f850a033492f5e745d79405a097a"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ab237f850a033492f5e745d79405a097a">_width</a></td></tr>
<tr class="memdesc:ab237f850a033492f5e745d79405a097a inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display width as modified by current rotation. <br /></td></tr>
<tr class="separator:ab237f850a033492f5e745d79405a097a inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bb0cbc2455f64dce2a5ec36307aa94 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="ab9bb0cbc2455f64dce2a5ec36307aa94"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ab9bb0cbc2455f64dce2a5ec36307aa94">_height</a></td></tr>
<tr class="memdesc:ab9bb0cbc2455f64dce2a5ec36307aa94 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display height as modified by current rotation. <br /></td></tr>
<tr class="separator:ab9bb0cbc2455f64dce2a5ec36307aa94 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8983cea8d81a7c8e9d05eef36318e2 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="a8f8983cea8d81a7c8e9d05eef36318e2"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a8f8983cea8d81a7c8e9d05eef36318e2">cursor_x</a></td></tr>
<tr class="memdesc:a8f8983cea8d81a7c8e9d05eef36318e2 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">x location to start print()ing text <br /></td></tr>
<tr class="separator:a8f8983cea8d81a7c8e9d05eef36318e2 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe0a38f6e6fd59cb81620c4696286c9 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="aebe0a38f6e6fd59cb81620c4696286c9"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aebe0a38f6e6fd59cb81620c4696286c9">cursor_y</a></td></tr>
<tr class="memdesc:aebe0a38f6e6fd59cb81620c4696286c9 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">y location to start print()ing text <br /></td></tr>
<tr class="separator:aebe0a38f6e6fd59cb81620c4696286c9 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6d23a386651136fd9530a5b7046591 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="a8c6d23a386651136fd9530a5b7046591"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a8c6d23a386651136fd9530a5b7046591">textcolor</a></td></tr>
<tr class="memdesc:a8c6d23a386651136fd9530a5b7046591 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit background color for print() <br /></td></tr>
<tr class="separator:a8c6d23a386651136fd9530a5b7046591 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e7a4efcab0b1588dc0cafa14b1fac1 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="a23e7a4efcab0b1588dc0cafa14b1fac1"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a23e7a4efcab0b1588dc0cafa14b1fac1">textbgcolor</a></td></tr>
<tr class="memdesc:a23e7a4efcab0b1588dc0cafa14b1fac1 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit text color for print() <br /></td></tr>
<tr class="separator:a23e7a4efcab0b1588dc0cafa14b1fac1 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c33cd6928ad6738a633e97727ae8773 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="a9c33cd6928ad6738a633e97727ae8773"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a9c33cd6928ad6738a633e97727ae8773">textsize_x</a></td></tr>
<tr class="memdesc:a9c33cd6928ad6738a633e97727ae8773 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired magnification in X-axis of text to print() <br /></td></tr>
<tr class="separator:a9c33cd6928ad6738a633e97727ae8773 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8588c3941eec083563c853ada3dd771 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="aa8588c3941eec083563c853ada3dd771"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aa8588c3941eec083563c853ada3dd771">textsize_y</a></td></tr>
<tr class="memdesc:aa8588c3941eec083563c853ada3dd771 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired magnification in Y-axis of text to print() <br /></td></tr>
<tr class="separator:aa8588c3941eec083563c853ada3dd771 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a479d28fb11906ce516e983b1af926 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="a37a479d28fb11906ce516e983b1af926"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#a37a479d28fb11906ce516e983b1af926">rotation</a></td></tr>
<tr class="memdesc:a37a479d28fb11906ce516e983b1af926 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display rotation (0 thru 3) <br /></td></tr>
<tr class="separator:a37a479d28fb11906ce516e983b1af926 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bd603e01861212829d536312a7190b inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="ad6bd603e01861212829d536312a7190b"></a>
boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#ad6bd603e01861212829d536312a7190b">wrap</a></td></tr>
<tr class="memdesc:ad6bd603e01861212829d536312a7190b inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set, 'wrap' text at right edge of display. <br /></td></tr>
<tr class="separator:ad6bd603e01861212829d536312a7190b inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef3d4d239641084cd3825a8b1042e01 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="aaef3d4d239641084cd3825a8b1042e01"></a>
boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#aaef3d4d239641084cd3825a8b1042e01">_cp437</a></td></tr>
<tr class="memdesc:aaef3d4d239641084cd3825a8b1042e01 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set, use correct CP437 charset (default is off) <br /></td></tr>
<tr class="separator:aaef3d4d239641084cd3825a8b1042e01 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb94c3253f43dada05e1270e322fa06 inherit pro_attribs_class_adafruit___g_f_x"><td class="memItemLeft" align="right" valign="top"><a id="afeb94c3253f43dada05e1270e322fa06"></a>
<a class="el" href="struct_g_f_xfont.html">GFXfont</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adafruit___g_f_x.html#afeb94c3253f43dada05e1270e322fa06">gfxFont</a></td></tr>
<tr class="memdesc:afeb94c3253f43dada05e1270e322fa06 inherit pro_attribs_class_adafruit___g_f_x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to special font. <br /></td></tr>
<tr class="separator:afeb94c3253f43dada05e1270e322fa06 inherit pro_attribs_class_adafruit___g_f_x"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> is an intermediary class between <a class="el" href="class_adafruit___g_f_x.html">Adafruit_GFX</a> and various hardware-specific subclasses for different displays. It handles certain operations that are common to a range of displays (address window, area fills, etc.). Originally these were all color TFT displays interfaced via SPI, but it's since expanded to include color OLEDs and parallel-interfaced TFTs. THE NAME HAS BEEN KEPT TO AVOID BREAKING A LOT OF SUBCLASSES AND EXAMPLE CODE. Many of the class member functions similarly live on with names that don't necessarily accurately describe what they're doing, again to avoid breaking a lot of other code. If in doubt, read the comments. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae082216e8270f83132827a70cceeaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae082216e8270f83132827a70cceeaf3">&#9670;&nbsp;</a></span>Adafruit_SPITFT() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Adafruit_SPITFT::Adafruit_SPITFT </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>mosi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>sck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>rst</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>miso</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> constructor for software (bitbang) SPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Display width in pixels at default rotation setting (0). </td></tr>
    <tr><td class="paramname">h</td><td>Display height in pixels at default rotation setting (0). </td></tr>
    <tr><td class="paramname">cs</td><td>Arduino pin # for chip-select (-1 if unused, tie CS low). </td></tr>
    <tr><td class="paramname">dc</td><td>Arduino pin # for data/command select (required). </td></tr>
    <tr><td class="paramname">mosi</td><td>Arduino pin # for bitbang SPI MOSI signal (required). </td></tr>
    <tr><td class="paramname">sck</td><td>Arduino pin # for bitbang SPI SCK signal (required). </td></tr>
    <tr><td class="paramname">rst</td><td>Arduino pin # for display reset (optional, display reset can be tied to MCU reset, default of -1 means unused). </td></tr>
    <tr><td class="paramname">miso</td><td>Arduino pin # for bitbang SPI MISO signal (optional, -1 default, many displays don't support SPI read). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Output pins are not initialized; application typically will need to call subclass' <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a81fb1a7842c52fa1992569880f4ea494" title="Display-specific initialization function. ">begin()</a> function, which in turn calls this library's <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a95164c088118b25d8e3efe48f9e86dbe" title="Configure microcontroller pins for TFT interfacing. Typically called by a subclass&#39; begin() function...">initSPI()</a> function to initialize pins. </dd></dl>

</div>
</div>
<a id="a2c3433ca3e3f9c5209765c46751bb674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3433ca3e3f9c5209765c46751bb674">&#9670;&nbsp;</a></span>Adafruit_SPITFT() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Adafruit_SPITFT::Adafruit_SPITFT </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>rst</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> constructor for hardware SPI using the board's default SPI peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Display width in pixels at default rotation setting (0). </td></tr>
    <tr><td class="paramname">h</td><td>Display height in pixels at default rotation setting (0). </td></tr>
    <tr><td class="paramname">cs</td><td>Arduino pin # for chip-select (-1 if unused, tie CS low). </td></tr>
    <tr><td class="paramname">dc</td><td>Arduino pin # for data/command select (required). </td></tr>
    <tr><td class="paramname">rst</td><td>Arduino pin # for display reset (optional, display reset can be tied to MCU reset, default of -1 means unused). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Output pins are not initialized; application typically will need to call subclass' <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a81fb1a7842c52fa1992569880f4ea494" title="Display-specific initialization function. ">begin()</a> function, which in turn calls this library's <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a95164c088118b25d8e3efe48f9e86dbe" title="Configure microcontroller pins for TFT interfacing. Typically called by a subclass&#39; begin() function...">initSPI()</a> function to initialize pins. </dd></dl>

</div>
</div>
<a id="abd847be5c9f71e5741d41805118f05c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd847be5c9f71e5741d41805118f05c8">&#9670;&nbsp;</a></span>Adafruit_SPITFT() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Adafruit_SPITFT::Adafruit_SPITFT </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPIClass *&#160;</td>
          <td class="paramname"><em>spiClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>rst</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> constructor for hardware SPI using a specific SPI peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Display width in pixels at default rotation (0). </td></tr>
    <tr><td class="paramname">h</td><td>Display height in pixels at default rotation (0). </td></tr>
    <tr><td class="paramname">spiClass</td><td>Pointer to SPIClass type (e.g. &amp;SPI or &amp;SPI1). </td></tr>
    <tr><td class="paramname">cs</td><td>Arduino pin # for chip-select (-1 if unused, tie CS low). </td></tr>
    <tr><td class="paramname">dc</td><td>Arduino pin # for data/command select (required). </td></tr>
    <tr><td class="paramname">rst</td><td>Arduino pin # for display reset (optional, display reset can be tied to MCU reset, default of -1 means unused). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Output pins are not initialized in constructor; application typically will need to call subclass' <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a81fb1a7842c52fa1992569880f4ea494" title="Display-specific initialization function. ">begin()</a> function, which in turn calls this library's <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a95164c088118b25d8e3efe48f9e86dbe" title="Configure microcontroller pins for TFT interfacing. Typically called by a subclass&#39; begin() function...">initSPI()</a> function to initialize pins. EXCEPT...if you have built your own SERCOM SPI peripheral (calling the SPIClass constructor) rather than one of the built-in SPI devices (e.g. &amp;SPI, &amp;SPI1 and so forth), you will need to call the <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a81fb1a7842c52fa1992569880f4ea494" title="Display-specific initialization function. ">begin()</a> function for your object as well as pinPeripheral() for the MOSI, MISO and SCK pins to configure GPIO manually. Do this BEFORE calling the display-specific begin or init function. Unfortunate but unavoidable. </dd></dl>

</div>
</div>
<a id="a1a4a822c07b817cea78dfb35dbaa4525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4a822c07b817cea78dfb35dbaa4525">&#9670;&nbsp;</a></span>Adafruit_SPITFT() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Adafruit_SPITFT::Adafruit_SPITFT </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_adafruit___s_p_i_t_f_t_8h.html#a4a7dffd73fe8924b90709aa7e6e366e8">tftBusWidth</a>&#160;</td>
          <td class="paramname"><em>busWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>wr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>cs</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>rst</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>rd</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> constructor for parallel display connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Display width in pixels at default rotation (0). </td></tr>
    <tr><td class="paramname">h</td><td>Display height in pixels at default rotation (0). </td></tr>
    <tr><td class="paramname">busWidth</td><td>If tft16 (enumeration in header file), is a 16-bit parallel connection, else 8-bit. 16-bit isn't fully implemented or tested yet so applications should pass "tft8bitbus" for now...needed to stick a required enum argument in there to disambiguate this constructor from the soft-SPI case. Argument is ignored on 8-bit architectures (no 'wide' support there since PORTs are 8 bits anyway). </td></tr>
    <tr><td class="paramname">d0</td><td>Arduino pin # for data bit 0 (1+ are extrapolated). The 8 (or 16) data bits MUST be contiguous and byte- aligned (or word-aligned for wide interface) within the same PORT register (might not correspond to Arduino pin sequence). </td></tr>
    <tr><td class="paramname">wr</td><td>Arduino pin # for write strobe (required). </td></tr>
    <tr><td class="paramname">dc</td><td>Arduino pin # for data/command select (required). </td></tr>
    <tr><td class="paramname">cs</td><td>Arduino pin # for chip-select (optional, -1 if unused, tie CS low). </td></tr>
    <tr><td class="paramname">rst</td><td>Arduino pin # for display reset (optional, display reset can be tied to MCU reset, default of -1 means unused). </td></tr>
    <tr><td class="paramname">rd</td><td>Arduino pin # for read strobe (optional, -1 if unused). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Output pins are not initialized; application typically will need to call subclass' <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a81fb1a7842c52fa1992569880f4ea494" title="Display-specific initialization function. ">begin()</a> function, which in turn calls this library's <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a95164c088118b25d8e3efe48f9e86dbe" title="Configure microcontroller pins for TFT interfacing. Typically called by a subclass&#39; begin() function...">initSPI()</a> function to initialize pins. Yes, the name is a misnomer...this library originally handled only SPI displays, parallel being a recent addition (but not wanting to break existing code). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a81fb1a7842c52fa1992569880f4ea494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fb1a7842c52fa1992569880f4ea494">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Adafruit_SPITFT::begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Display-specific initialization function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>SPI frequency, in hz (or 0 for default or unused). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1928d1a2b27cc32422624ed54c0ea932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1928d1a2b27cc32422624ed54c0ea932">&#9670;&nbsp;</a></span>setAddrWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Adafruit_SPITFT::setAddrWindow </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up the specific display hardware's "address window" for subsequent pixel-pushing operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Leftmost pixel of area to be drawn (MUST be within display bounds at current rotation setting). </td></tr>
    <tr><td class="paramname">y</td><td>Topmost pixel of area to be drawn (MUST be within display bounds at current rotation setting). </td></tr>
    <tr><td class="paramname">w</td><td>Width of area to be drawn, in pixels (MUST be &gt;0 and, added to x, within display bounds at current rotation). </td></tr>
    <tr><td class="paramname">h</td><td>Height of area to be drawn, in pixels (MUST be &gt;0 and, added to x, within display bounds at current rotation). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95164c088118b25d8e3efe48f9e86dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95164c088118b25d8e3efe48f9e86dbe">&#9670;&nbsp;</a></span>initSPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::initSPI </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>freq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>spiMode</em> = <code>SPI_MODE0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure microcontroller pins for TFT interfacing. Typically called by a subclass' <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a81fb1a7842c52fa1992569880f4ea494" title="Display-specific initialization function. ">begin()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>SPI frequency when using hardware SPI. If default (0) is passed, will fall back on a device-specific value. Value is ignored when using software SPI or parallel connection. </td></tr>
    <tr><td class="paramname">spiMode</td><td>SPI mode when using hardware SPI. MUST be one of the values SPI_MODE0, SPI_MODE1, SPI_MODE2 or SPI_MODE3 defined in SPI.h. Do NOT attempt to pass '0' for SPI_MODE0 and so forth...the values are NOT the same! Use ONLY the defines! (Pity it's not an enum.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Another anachronistically-named function; this is called even when the display connection is parallel (not SPI). Also, this could probably be made private...quite a few class functions were generously put in the public section. </dd></dl>

</div>
</div>
<a id="a4eb7f9703e15a7a289e61f5bc450ca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb7f9703e15a7a289e61f5bc450ca4d">&#9670;&nbsp;</a></span>setSPISpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::setSPISpeed </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow changing the SPI clock speed after initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Desired frequency of SPI clock, may not be the end frequency you get based on what the chip can do! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa40496b6d0513cc9a8eef190ced96238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40496b6d0513cc9a8eef190ced96238">&#9670;&nbsp;</a></span>sendCommand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::sendCommand </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>commandByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataBytes</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numDataBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> Send Command handles complete sending of commands and data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandByte</td><td>The Command Byte </td></tr>
    <tr><td class="paramname">dataBytes</td><td>A pointer to the Data bytes to send </td></tr>
    <tr><td class="paramname">numDataBytes</td><td>The number of bytes we should send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25f7cee641ff20ecdb38ca6048e8b68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f7cee641ff20ecdb38ca6048e8b68c">&#9670;&nbsp;</a></span>sendCommand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::sendCommand </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>commandByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>dataBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numDataBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_adafruit___s_p_i_t_f_t.html" title="Adafruit_SPITFT is an intermediary class between Adafruit_GFX and various hardware-specific subclasse...">Adafruit_SPITFT</a> Send Command handles complete sending of commands and const data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandByte</td><td>The Command Byte </td></tr>
    <tr><td class="paramname">dataBytes</td><td>A pointer to the Data bytes to send </td></tr>
    <tr><td class="paramname">numDataBytes</td><td>The number of bytes we should send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a641ccc4f159129259ee08738cb99627b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641ccc4f159129259ee08738cb99627b">&#9670;&nbsp;</a></span>readcommand8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Adafruit_SPITFT::readcommand8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>commandByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 8 bits of data from display configuration memory (not RAM). This is highly undocumented/supported and should be avoided, function is only included because some of the examples use it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandByte</td><td>The command register to read data from. </td></tr>
    <tr><td class="paramname">index</td><td>The byte index into the command to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unsigned 8-bit data read from display register. </dd></dl>

</div>
</div>
<a id="a795dcd9f5f850c057b0a896204fc7d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795dcd9f5f850c057b0a896204fc7d55">&#9670;&nbsp;</a></span>writePixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::writePixel </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a single pixel to the display at requested coordinates. Not self-contained; should follow a <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a> call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position (0 = left). </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position (0 = top). </td></tr>
    <tr><td class="paramname">color</td><td>16-bit pixel color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_adafruit___g_f_x.html#ab66a1577ec595a254e4492d641b36fd8">Adafruit_GFX</a>.</p>

</div>
</div>
<a id="af28a0d81eee528cabe3f2fbca6815f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28a0d81eee528cabe3f2fbca6815f05">&#9670;&nbsp;</a></span>writePixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::writePixels </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bigEndian</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue a series of pixels from memory to the display. Not self- contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a> and <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a1928d1a2b27cc32422624ed54c0ea932" title="Set up the specific display hardware&#39;s &quot;address window&quot; for subsequent pixel-pushing operations...">setAddrWindow()</a> calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colors</td><td>Pointer to array of 16-bit pixel values in '565' RGB format. </td></tr>
    <tr><td class="paramname">len</td><td>Number of elements in 'colors' array. </td></tr>
    <tr><td class="paramname">block</td><td>If true (default case if unspecified), function blocks until DMA transfer is complete. This is simply IGNORED if DMA is not enabled. If false, the function returns immediately after the last DMA transfer is started, and one should use the <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ae69f8c2c187cccd5c9df9c25d488f1e5" title="Wait for the last DMA transfer in a prior non-blocking writePixels() call to complete. This does nothing if DMA is not enabled, and is not needed if blocking writePixels() was used (as is the default case). ">dmaWait()</a> function before doing ANY other display-related activities (or even any SPI-related activities, if using an SPI display that shares the bus with other devices). </td></tr>
    <tr><td class="paramname">bigEndian</td><td>If using DMA, and if set true, bitmap in memory is in big-endian order (most significant byte first). By default this is false, as most microcontrollers seem to be little-endian and 16-bit pixel values must be byte-swapped before issuing to the display (which tend to be big-endian when using SPI or 8-bit parallel). If an application can optimize around this &ndash; for example, a bitmap in a uint16_t array having the byte values already reordered big-endian, this can save some processing time here, ESPECIALLY if using this function's non-blocking DMA mode. Not all cases are covered...this is really here only for SAMD DMA and much forethought on the application side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42824e0f1475f2b3df335d31651dc75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42824e0f1475f2b3df335d31651dc75a">&#9670;&nbsp;</a></span>writeColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::writeColor </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue a series of pixels, all the same color. Not self- contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a> and <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a1928d1a2b27cc32422624ed54c0ea932" title="Set up the specific display hardware&#39;s &quot;address window&quot; for subsequent pixel-pushing operations...">setAddrWindow()</a> calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>16-bit pixel color in '565' RGB format. </td></tr>
    <tr><td class="paramname">len</td><td>Number of pixels to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8df7d60b7c8500b31d0a8f59999c3df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df7d60b7c8500b31d0a8f59999c3df1">&#9670;&nbsp;</a></span>writeFillRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::writeFillRect </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a filled rectangle to the display. Not self-contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a>. Typically used by higher-level graphics primitives; user code shouldn't need to call this and is likely to use the self-contained <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a5964fdb249fb43869c649198e13b727b" title="Draw a filled rectangle to the display. Self-contained and provides its own transaction as needed (se...">fillRect()</a> instead. <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1" title="Draw a filled rectangle to the display. Not self-contained; should follow startWrite(). Typically used by higher-level graphics primitives; user code shouldn&#39;t need to call this and is likely to use the self-contained fillRect() instead. writeFillRect() performs its own edge clipping and rejection; see writeFillRectPreclipped() for a more &#39;raw&#39; implementation. ">writeFillRect()</a> performs its own edge clipping and rejection; see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a6ef20b186a133d416f9ba71fb884d275" title="A lower-level version of writeFillRect(). This version requires all inputs are in-bounds, that width and height are positive, and no part extends offscreen. NO EDGE CLIPPING OR REJECTION IS PERFORMED. If higher-level graphics primitives are written to handle their own clipping earlier in the drawing process, this can avoid unnecessary function calls and repeated clipping operations in the lower-level functions. ">writeFillRectPreclipped()</a> for a more 'raw' implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position of first corner. </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position of first corner. </td></tr>
    <tr><td class="paramname">w</td><td>Rectangle width in pixels (positive = right of first corner, negative = left of first corner). </td></tr>
    <tr><td class="paramname">h</td><td>Rectangle height in pixels (positive = below first corner, negative = above first corner). </td></tr>
    <tr><td class="paramname">color</td><td>16-bit fill color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Written in this deep-nested way because C by definition will optimize for the 'if' case, not the 'else' &ndash; avoids branches and rejects clipped rectangles at the least-work possibility. </dd></dl>

<p>Reimplemented from <a class="el" href="class_adafruit___g_f_x.html#a60133faeabc10f9d909674bc4c5aabc6">Adafruit_GFX</a>.</p>

</div>
</div>
<a id="a06312f906256fd7e72efb21df85d2b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06312f906256fd7e72efb21df85d2b96">&#9670;&nbsp;</a></span>writeFastHLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::writeFastHLine </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a horizontal line on the display. Performs edge clipping and rejection. Not self-contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a>. Typically used by higher-level graphics primitives; user code shouldn't need to call this and is likely to use the self- contained <a class="el" href="class_adafruit___s_p_i_t_f_t.html#aef1099605952f87fbdf59bc480a7a894" title="Draw a horizontal line on the display. Self-contained and provides its own transaction as needed (see...">drawFastHLine()</a> instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position of first point. </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position of first point. </td></tr>
    <tr><td class="paramname">w</td><td>Line width in pixels (positive = right of first point, negative = point of first corner). </td></tr>
    <tr><td class="paramname">color</td><td>16-bit line color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_adafruit___g_f_x.html#ad85469e8be73f90932058fba1d4e5cbd">Adafruit_GFX</a>.</p>

</div>
</div>
<a id="a9b5f5765414c6b0c94c9a060427803ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5f5765414c6b0c94c9a060427803ec">&#9670;&nbsp;</a></span>writeFastVLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::writeFastVLine </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a vertical line on the display. Performs edge clipping and rejection. Not self-contained; should follow <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ad15008e1d7d71ccc707f6efab2a86e6b" title="Call before issuing command(s) or data to display. Performs chip-select (if required) and starts an S...">startWrite()</a>. Typically used by higher-level graphics primitives; user code shouldn't need to call this and is likely to use the self- contained <a class="el" href="class_adafruit___s_p_i_t_f_t.html#ab9bf597887f7098e55e7280d548bc127" title="Draw a vertical line on the display. Self-contained and provides its own transaction as needed (see w...">drawFastVLine()</a> instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position of first point. </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position of first point. </td></tr>
    <tr><td class="paramname">h</td><td>Line height in pixels (positive = below first point, negative = above first point). </td></tr>
    <tr><td class="paramname">color</td><td>16-bit line color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_adafruit___g_f_x.html#ae12d09670433af17e666a203b51715f7">Adafruit_GFX</a>.</p>

</div>
</div>
<a id="a6ef20b186a133d416f9ba71fb884d275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef20b186a133d416f9ba71fb884d275">&#9670;&nbsp;</a></span>writeFillRectPreclipped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::writeFillRectPreclipped </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A lower-level version of <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1" title="Draw a filled rectangle to the display. Not self-contained; should follow startWrite(). Typically used by higher-level graphics primitives; user code shouldn&#39;t need to call this and is likely to use the self-contained fillRect() instead. writeFillRect() performs its own edge clipping and rejection; see writeFillRectPreclipped() for a more &#39;raw&#39; implementation. ">writeFillRect()</a>. This version requires all inputs are in-bounds, that width and height are positive, and no part extends offscreen. NO EDGE CLIPPING OR REJECTION IS PERFORMED. If higher-level graphics primitives are written to handle their own clipping earlier in the drawing process, this can avoid unnecessary function calls and repeated clipping operations in the lower-level functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position of first corner. MUST BE WITHIN SCREEN BOUNDS. </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position of first corner. MUST BE WITHIN SCREEN BOUNDS. </td></tr>
    <tr><td class="paramname">w</td><td>Rectangle width in pixels. MUST BE POSITIVE AND NOT EXTEND OFF SCREEN. </td></tr>
    <tr><td class="paramname">h</td><td>Rectangle height in pixels. MUST BE POSITIVE AND NOT EXTEND OFF SCREEN. </td></tr>
    <tr><td class="paramname">color</td><td>16-bit fill color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a new function, no graphics primitives besides rects and horizontal/vertical lines are written to best use this yet. </dd></dl>

</div>
</div>
<a id="a5e118fc9c0fb141c8ee9f14e49f20704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e118fc9c0fb141c8ee9f14e49f20704">&#9670;&nbsp;</a></span>drawPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::drawPixel </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a single pixel to the display at requested coordinates. Self-contained and provides its own transaction as needed (see writePixel(x,y,color) for a lower-level variant). Edge clipping is performed here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position (0 = left). </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position (0 = top). </td></tr>
    <tr><td class="paramname">color</td><td>16-bit pixel color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_adafruit___g_f_x.html#ab7fbf72885c873266f9c7eb53b5c8896">Adafruit_GFX</a>.</p>

</div>
</div>
<a id="a5964fdb249fb43869c649198e13b727b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5964fdb249fb43869c649198e13b727b">&#9670;&nbsp;</a></span>fillRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::fillRect </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a filled rectangle to the display. Self-contained and provides its own transaction as needed (see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1" title="Draw a filled rectangle to the display. Not self-contained; should follow startWrite(). Typically used by higher-level graphics primitives; user code shouldn&#39;t need to call this and is likely to use the self-contained fillRect() instead. writeFillRect() performs its own edge clipping and rejection; see writeFillRectPreclipped() for a more &#39;raw&#39; implementation. ">writeFillRect()</a> or <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a6ef20b186a133d416f9ba71fb884d275" title="A lower-level version of writeFillRect(). This version requires all inputs are in-bounds, that width and height are positive, and no part extends offscreen. NO EDGE CLIPPING OR REJECTION IS PERFORMED. If higher-level graphics primitives are written to handle their own clipping earlier in the drawing process, this can avoid unnecessary function calls and repeated clipping operations in the lower-level functions. ">writeFillRectPreclipped()</a> for lower-level variants). Edge clipping and rejection is performed here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position of first corner. </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position of first corner. </td></tr>
    <tr><td class="paramname">w</td><td>Rectangle width in pixels (positive = right of first corner, negative = left of first corner). </td></tr>
    <tr><td class="paramname">h</td><td>Rectangle height in pixels (positive = below first corner, negative = above first corner). </td></tr>
    <tr><td class="paramname">color</td><td>16-bit fill color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This repeats the <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1" title="Draw a filled rectangle to the display. Not self-contained; should follow startWrite(). Typically used by higher-level graphics primitives; user code shouldn&#39;t need to call this and is likely to use the self-contained fillRect() instead. writeFillRect() performs its own edge clipping and rejection; see writeFillRectPreclipped() for a more &#39;raw&#39; implementation. ">writeFillRect()</a> function almost in its entirety, with the addition of a transaction start/end. It's done this way (rather than starting the transaction and calling <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a8df7d60b7c8500b31d0a8f59999c3df1" title="Draw a filled rectangle to the display. Not self-contained; should follow startWrite(). Typically used by higher-level graphics primitives; user code shouldn&#39;t need to call this and is likely to use the self-contained fillRect() instead. writeFillRect() performs its own edge clipping and rejection; see writeFillRectPreclipped() for a more &#39;raw&#39; implementation. ">writeFillRect()</a> to handle clipping and so forth) so that the transaction isn't performed at all if the rectangle is rejected. It's really not that much code. </dd></dl>

</div>
</div>
<a id="aef1099605952f87fbdf59bc480a7a894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1099605952f87fbdf59bc480a7a894">&#9670;&nbsp;</a></span>drawFastHLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::drawFastHLine </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a horizontal line on the display. Self-contained and provides its own transaction as needed (see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a06312f906256fd7e72efb21df85d2b96" title="Draw a horizontal line on the display. Performs edge clipping and rejection. Not self-contained; shou...">writeFastHLine()</a> for a lower-level variant). Edge clipping and rejection is performed here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position of first point. </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position of first point. </td></tr>
    <tr><td class="paramname">w</td><td>Line width in pixels (positive = right of first point, negative = point of first corner). </td></tr>
    <tr><td class="paramname">color</td><td>16-bit line color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This repeats the <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a06312f906256fd7e72efb21df85d2b96" title="Draw a horizontal line on the display. Performs edge clipping and rejection. Not self-contained; shou...">writeFastHLine()</a> function almost in its entirety, with the addition of a transaction start/end. It's done this way (rather than starting the transaction and calling <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a06312f906256fd7e72efb21df85d2b96" title="Draw a horizontal line on the display. Performs edge clipping and rejection. Not self-contained; shou...">writeFastHLine()</a> to handle clipping and so forth) so that the transaction isn't performed at all if the line is rejected. </dd></dl>

</div>
</div>
<a id="ab9bf597887f7098e55e7280d548bc127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bf597887f7098e55e7280d548bc127">&#9670;&nbsp;</a></span>drawFastVLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::drawFastVLine </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a vertical line on the display. Self-contained and provides its own transaction as needed (see <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a06312f906256fd7e72efb21df85d2b96" title="Draw a horizontal line on the display. Performs edge clipping and rejection. Not self-contained; shou...">writeFastHLine()</a> for a lower- level variant). Edge clipping and rejection is performed here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Horizontal position of first point. </td></tr>
    <tr><td class="paramname">y</td><td>Vertical position of first point. </td></tr>
    <tr><td class="paramname">h</td><td>Line height in pixels (positive = below first point, negative = above first point). </td></tr>
    <tr><td class="paramname">color</td><td>16-bit line color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This repeats the <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a9b5f5765414c6b0c94c9a060427803ec" title="Draw a vertical line on the display. Performs edge clipping and rejection. Not self-contained; should...">writeFastVLine()</a> function almost in its entirety, with the addition of a transaction start/end. It's done this way (rather than starting the transaction and calling <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a9b5f5765414c6b0c94c9a060427803ec" title="Draw a vertical line on the display. Performs edge clipping and rejection. Not self-contained; should...">writeFastVLine()</a> to handle clipping and so forth) so that the transaction isn't performed at all if the line is rejected. </dd></dl>

<p>Reimplemented from <a class="el" href="class_adafruit___g_f_x.html#a1cffbb1d69c5faf49cd0cff27686a837">Adafruit_GFX</a>.</p>

</div>
</div>
<a id="a53b00726d150600cd8f0feb9a897fb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b00726d150600cd8f0feb9a897fb64">&#9670;&nbsp;</a></span>pushColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::pushColor </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Essentially <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a795dcd9f5f850c057b0a896204fc7d55" title="Draw a single pixel to the display at requested coordinates. Not self-contained; should follow a star...">writePixel()</a> with a transaction around it. I don't think this is in use by any of our code anymore (believe it was for some older BMP-reading examples), but is kept here in case any user code relies on it. Consider it DEPRECATED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>16-bit pixel color in '565' RGB format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2984b1d3854ed521259cd8208071b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2984b1d3854ed521259cd8208071b55">&#9670;&nbsp;</a></span>drawRGBBitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::drawRGBBitmap </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pcolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a 16-bit image (565 RGB) at the specified (x,y) position. For 16-bit display devices; no color reduction performed. Adapted from <a href="https://github.com/PaulStoffregen/ILI9341_t3">https://github.com/PaulStoffregen/ILI9341_t3</a> by Marc MERLIN. See examples/pictureEmbed to use this. 5/6/2017: function name and arguments have changed for compatibility with current GFX library and to avoid naming problems in prior implementation. Formerly <a class="el" href="class_adafruit___g_f_x.html#a805a15f1b3ea9eff5d1666b8e6db1c56" title="Draw a PROGMEM-resident 1-bit image at the specified (x,y) position, using the specified foreground c...">drawBitmap()</a> with arguments in different order. Handles its own transaction and edge clipping/rejection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Top left corner horizontal coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>Top left corner vertical coordinate. </td></tr>
    <tr><td class="paramname">pcolors</td><td>Pointer to 16-bit array of pixel values. </td></tr>
    <tr><td class="paramname">w</td><td>Width of bitmap in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of bitmap in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21a13b3b0e6e0bb1328b5050559dd919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a13b3b0e6e0bb1328b5050559dd919">&#9670;&nbsp;</a></span>invertDisplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::invertDisplay </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the colors of the display (if supported by hardware). Self-contained, no transaction setup required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>true = inverted display, false = normal display. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a656f04e5a60f1ff7cddc2934fa676b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656f04e5a60f1ff7cddc2934fa676b8b">&#9670;&nbsp;</a></span>color565()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Adafruit_SPITFT::color565 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given 8-bit red, green and blue values, return a 'packed' 16-bit color value in '565' RGB format (5 bits red, 6 bits green, 5 bits blue). This is just a mathematical operation, no hardware is touched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red</td><td>8-bit red brightnesss (0 = off, 255 = max). </td></tr>
    <tr><td class="paramname">green</td><td>8-bit green brightnesss (0 = off, 255 = max). </td></tr>
    <tr><td class="paramname">blue</td><td>8-bit blue brightnesss (0 = off, 255 = max). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'Packed' 16-bit color value (565 format). </dd></dl>

</div>
</div>
<a id="a76dfbee0ce62682988badc0dbbdc5790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dfbee0ce62682988badc0dbbdc5790">&#9670;&nbsp;</a></span>spiWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::spiWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue a single 8-bit value to the display. Chip-select, transaction and data/command selection must have been previously set &ndash; this ONLY issues the byte. This is another of those functions in the library with a now-not-accurate name that's being maintained for compatibility with outside code. This function is used even if display connection is parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>8-bit value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0169fcf8898413bba568a93c1617e8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0169fcf8898413bba568a93c1617e8bb">&#9670;&nbsp;</a></span>writeCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::writeCommand </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single command byte to the display. Chip-select and transaction must have been previously set &ndash; this ONLY sets the device to COMMAND mode, issues the byte and then restores DATA mode. There is no corresponding explicit writeData() function &ndash; just use <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a76dfbee0ce62682988badc0dbbdc5790" title="Issue a single 8-bit value to the display. Chip-select, transaction and data/command selection must h...">spiWrite()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>8-bit command to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6904156a9bb832fc510ae6df33e936e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6904156a9bb832fc510ae6df33e936e5">&#9670;&nbsp;</a></span>spiRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Adafruit_SPITFT::spiRead </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single 8-bit value from the display. Chip-select and transaction must have been previously set &ndash; this ONLY reads the byte. This is another of those functions in the library with a now-not-accurate name that's being maintained for compatibility with outside code. This function is used even if display connection is parallel. </p>
<dl class="section return"><dt>Returns</dt><dd>Unsigned 8-bit value read (always zero if USE_FAST_PINIO is not supported by the MCU architecture). </dd></dl>

</div>
</div>
<a id="af8d3977fd1a982a376cc4d98949d7269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d3977fd1a982a376cc4d98949d7269">&#9670;&nbsp;</a></span>SPI_WRITE16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::SPI_WRITE16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue a single 16-bit value to the display. Chip-select, transaction and data/command selection must have been previously set &ndash; this ONLY issues the word. Despite the name, this function is used even if display connection is parallel; name was maintaned for backward compatibility. Naming is also not consistent with the 8-bit version, <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a76dfbee0ce62682988badc0dbbdc5790" title="Issue a single 8-bit value to the display. Chip-select, transaction and data/command selection must h...">spiWrite()</a>. Sorry about that. Again, staying compatible with outside code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>16-bit value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97e8acadecd766abcb735e0e89c81149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e8acadecd766abcb735e0e89c81149">&#9670;&nbsp;</a></span>SPI_WRITE32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Adafruit_SPITFT::SPI_WRITE32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue a single 32-bit value to the display. Chip-select, transaction and data/command selection must have been previously set &ndash; this ONLY issues the longword. Despite the name, this function is used even if display connection is parallel; name was maintaned for backward compatibility. Naming is also not consistent with the 8-bit version, <a class="el" href="class_adafruit___s_p_i_t_f_t.html#a76dfbee0ce62682988badc0dbbdc5790" title="Issue a single 8-bit value to the display. Chip-select, transaction and data/command selection must h...">spiWrite()</a>. Sorry about that. Again, staying compatible with outside code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>32-bit value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d4982ab4b15c7b3bc30c553e1abf279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4982ab4b15c7b3bc30c553e1abf279">&#9670;&nbsp;</a></span>SPI_MISO_READ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Adafruit_SPITFT::SPI_MISO_READ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the state of the software (bitbang) SPI MISO line. </p>
<dl class="section return"><dt>Returns</dt><dd>true if HIGH, false if LOW. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a65e9eb00f665cadb411babf9c506a01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e9eb00f665cadb411babf9c506a01d">&#9670;&nbsp;</a></span>_freq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Adafruit_SPITFT::_freq = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI bitrate (if no SPI transactions) </p>
<p>Dummy var to keep subclasses happy. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_adafruit___s_p_i_t_f_t_8h_source.html">Adafruit_SPITFT.h</a></li>
<li><a class="el" href="_adafruit___s_p_i_t_f_t_8cpp.html">Adafruit_SPITFT.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
